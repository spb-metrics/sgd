<?php
/*
LICENÇA PÚBLICA GERAL GNU
Versão 2, junho de 1991

Copyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass Ave,
Cambridge, MA 02139, USA

A qualquer pessoa é permitido copiar e distribuir cópias deste documento de
licença, desde que sem qualquer alteração.

Introdução

As licenças de software são normalmente desenvolvidas para restringir a
liberdade de compartilhá-lo e modifica-lo. Pelo contrário, a Licença Pública
Geral GNU pretende garantir a sua liberdade de compartilhar e modificar o
software livre -- garantindo que o software será livre para os seus
utilizadores. Esta Licença Pública Geral aplica-se à maioria do software da
Free Software Foundation e a qualquer outro programa ao qual o seu autor decida
aplicá-la. (Algum software da FSF é cobertos pela Licença Pública Geral de
Bibliotecas.) Também poderá aplicá-la aos seus programas.

Quando nos referimos a software livre, estamo-nos a referir à liberdade e não
ao preço. A Licença Pública Geral (GPL - General Public Licence - em Inglês.)
foi desenvolvida para garantir a sua liberdade de distribuir cópias de software
livre (e cobrar por isso, se quiser); receber o código-fonte ou ter acesso a
ele, se quiser; poder modificar o software ou utilizar partes dele em novos
programas livres; e que saiba que está no seu direito de o fazer.

Para proteger seus direitos, precisamos fazer restrições que impeçam a qualquer
um negar estes direitos ou solicitar que você abdique deles. Estas restrições
traduzem-se em certas responsabilidades para si, caso venha a distribuir cópias
do software, ou modificá-lo.

Por exemplo, se você distribuir cópias de um programa sobre este tipo de
licenciamento, gratuitamente ou por alguma quantia, tem que fornecer igualmente
todos os direitos que possui sobre ele. Tem igualmente que garantir que os
destinatários recebam ou possam obter o código-fonte. Além disto, tem que
fornecer-lhes estes termos para que possam conhecer seus direitos.

Nós protegemos seus direitos por duas formas que se completam: (1) com
copyright do software e (2) com a oferta desta licença, que lhe dá permissão
legal para copiar, distribuir e/ou modificar o software.

Além disso, tanto para a protecção do autor quanto a nossa, gostaríamos de
certificar-nos de que todos entendam que não há qualquer garantia sobre o
software livre. Se o software é modificado por alguém e redistribuído, queremos
que seus destinatários saibam que o que eles obtiveram não é original, de forma
que qualquer problema introduzido por terceiros não interfira na reputação do
autor original.

Finalmente, qualquer programa é ameaçado constantemente por patentes de
software. Queremos evitar o perigo de que distribuidores de software livre
obtenham patentes individuais sobre o software, o que teria o efeito de tornar
o software proprietário. Para prevenir isso, deixamos claro que qualquer
patente tem que ser licenciada para uso livre e gratuito por qualquer pessoa,
ou então que nem necessite ser licenciada.

Os termos e condições precisas para cópia, distribuição e modificação
encontram-se abaixo:

LICENÇA PÚBLICA GERAL GNU TERMOS E CONDIÇÕES PARA CÓPIA, DISTRIBUIÇÃO E
MODIFICAÇÃO

0. Esta licença aplica-se a qualquer programa ou outro trabalho que contenha um
aviso colocado pelo detentor dos direitos autorais informando que aquele pode
ser distribuído sob as condições desta Licença Pública Geral. O "Programa"
abaixo refere-se a qualquer programa ou trabalho e "trabalho baseado no
Programa" significa tanto o Programa em si, como quaisquer trabalhos derivados,
de acordo com a lei de direitos de autor: isto quer dizer um trabalho que
contenha o Programa ou parte dele, tanto na forma original ou modificado, e/ou
tradução para outros idiomas. ***(Doravante o termo "modificação" ou sinónimos
serão usados livremente.) *** Cada licenciado é mencionado como "você".

Actividades outras que a cópia, a distribuição e modificação não estão cobertas
por esta Licença; elas estão fora do seu âmbito. O acto de executar o Programa
não é restringido e o resultado do Programa é coberto pela licença apenas se o
seu conteúdo contenha trabalhos baseados no Programa (independentemente de
terem sido gerados pela execução do Programa). Este último ponto depende das
funcionalidades específicas de cada programa.

1. Você pode copiar e distribuir cópias fiéis do código-fonte do Programa da
mesma forma que você o recebeu, usando qualquer meio, deste que inclua em cada
cópia um aviso de direitos de autor e uma declaração de inexistência de
garantias; mantenha intactos todos os avisos que se referem a esta Licença e à
ausência total de garantias; e forneça aos destinatários do Programa uma cópia
desta Licença, em conjunto com o Programa.

Você pode cobrar pelo acto físico de transferir uma cópia e pode,
opcionalmente, oferecer garantias em troca de pagamento.

2. Você pode modificar sua cópia ou cópias do Programa, ou qualquer parte dele,
gerando assim um trabalho derivado, copiar e distribuir essas modificações ou
trabalhos sob os termos da secção 1 acima, desde que se enquadre nas seguintes
condições:

a) Os arquivos modificados devem conter avisos proeminentes afirmando que você
alterou os arquivos, incluindo a data de qualquer alteração.

b) Deve ser licenciado, sob os termos desta Licença, integralmente e sem custo
algum para terceiros, qualquer trabalho seu que contenha ou seja derivado do
Programa ou de parte dele.

c) Se qualquer programa modificado, quando executado, lê normalmente comandos
interactivamente, tem que fazer com que, quando iniciado o uso interactivo,
seja impresso ou mostrado um anúncio de que não há qualquer garantia (ou então
que você fornece a garantia) e que os utilizadores podem redistribuir o
programa sob estas condições, ainda informando os utilizadores como consultar
uma cópia desta Licença. (Excepção: se o Programa em si é interactivo mas
normalmente não imprime estes tipos de anúncios, então o seu trabalho derivado
não precisa imprimir um anúncio.)

Estas exigências aplicam-se ao trabalho derivado como um todo. Se secções
identificáveis de tal trabalho não são derivadas do Programa, e podem ser
razoavelmente consideradas trabalhos independentes e separados por si só, então
esta Licença, e seus termos, não se aplicam a estas secções caso as distribua
como um trabalho separado. Mas se distribuir as mesmas secções como parte de um
todo que constitui trabalho derivado, a distribuição como um todo tem que
enquadrar-se nos termos desta Licença, cujos direitos para outros licenciados
se estendem ao todo, portanto também para toda e qualquer parte do programa,
independente de quem a escreveu.

Desta forma, esta secção não tem a intenção de reclamar direitos ou contestar
seus direitos sobre o trabalho escrito completamente por si; ao invés disso, a
intenção é a de exercitar o direito de controlar a distribuição de trabalhos,
derivados ou colectivos, baseados no Programa.

Adicionalmente, a mera adição ao Programa (ou a um trabalho derivado deste) de
um outro trabalho num volume de armazenamento ou meio de distribuição não faz
esse outro trabalho seja incluído no âmbito desta Licença.

3. Você pode copiar e distribuir o Programa (ou trabalho derivado, conforme
descrito na Secção 2) em código-objecto ou em forma executável sob os termos
das Secções 1 e 2 acima, desde que cumpra uma das seguintes alienas:

a) O faça acompanhar com o código-fonte completo e em forma acessível por
máquinas, código esse que tem que ser distribuído sob os termos das Secções 1 e
2 acima e em meio normalmente utilizado para o intercâmbio de software; ou,

b) O acompanhe com uma oferta escrita, válida por pelo menos três anos, de
fornecer a qualquer um, com um custo não superior ao custo de distribuição
física do material, uma cópia do código-fonte completo e em forma acessível por
máquinas,  código esse que tem que ser distribuído sob os termos das Secções 1
e 2 acima e em meio normalmente utilizado para o intercâmbio de software; ou,

c) O acompanhe com a informação que você recebeu em relação à oferta de
distribuição do código-fonte correspondente. (Esta alternativa é permitida
somente em distribuição não comerciais, e apenas se você recebeu o programa em
forma de código-objecto ou executável, com uma oferta de acordo com a Subsecção
b) acima.)

O código-fonte de um trabalho corresponde à forma de trabalho preferida para se
fazer modificações. Para um trabalho em forma executável, o código-fonte
completo significa todo o código-fonte de todos os módulos que ele contém, mais
quaisquer arquivos de definição de "interface", mais os "scripts" utilizados
para se controlar a compilação e a instalação do executável. Contudo, como
excepção especial, o código-fonte distribuído não precisa incluir qualquer
componente normalmente distribuído (tanto em forma original quanto binária) com
os maiores componentes (o compilador, o "kernel" etc.) do sistema operativo sob
o qual o executável funciona, a menos que o componente em si acompanhe o
executável.

Se a distribuição do executável ou código-objecto é feita através da oferta de
acesso a cópias em algum lugar, então oferecer o acesso equivalente a cópia, no
mesmo lugar, do código-fonte, equivale à distribuição do código-fonte, mesmo
que terceiros não sejam compelidos a copiar o código-fonte em conjunto com o
código-objecto.

4. Você não pode copiar, modificar, sublicenciar ou distribuir o Programa,
excepto de acordo com as condições expressas nesta Licença. Qualquer outra
tentativa de cópia, modificação, sublicenciamento ou distribuição do Programa
não é valida, e cancelará automaticamente os direitos que lhe foram fornecidos
por esta Licença. No entanto, terceiros que receberam de si cópias ou direitos,
fornecidos sob os termos desta Licença, não terão a sua licença terminada,
desde que permaneçam em total concordância com ela.

5. Você não é obrigado a aceitar esta Licença já que não a assinou. No entanto,
nada mais lhe dará permissão para modificar ou distribuir o Programa ou
trabalhos derivados deste. Estas acções são proibidas por lei, caso você não
aceite esta Licença. Desta forma, ao modificar ou distribuir o Programa (ou
qualquer trabalho derivado do Programa), você estará a indicar a sua total
concordância com os termos desta Licença, nomeadamente os termos e condições
para copiar, distribuir ou modificar o Programa, ou trabalhos baseados nele.

6. Cada vez que redistribuir o Programa (ou qualquer trabalho derivado), os
destinatários adquirirão automaticamente do autor original uma licença para
copiar, distribuir ou modificar o Programa, sujeitos a estes termos e
condições. Você não poderá impor aos destinatários qualquer outra restrição ao
exercício dos direitos então adquiridos. Você não é responsável em garantir a
concordância de terceiros a esta Licença.

7. Se, em consequência de decisões judiciais ou alegações de violação de
patentes ou quaisquer outras razões (não limitadas a assuntos relacionados a
patentes), lhe forem impostas condições (por ordem judicial, acordos ou outras
formas) e que contradigam as condições desta Licença, elas não o livram das
condições desta Licença. Se não puder distribuir de forma a satisfazer
simultaneamente suas obrigações para com esta Licença e para com as outras
obrigações pertinentes, então como consequência você não poderá distribuir o
Programa. Por exemplo, se uma licença de patente não permitir a redistribuição,
sem obrigação ao pagamento de "royalties", por todos aqueles que receberem
cópias directa ou indirectamente de si, então a única forma de você satisfazer
a licença de patente e a esta Licença seria a de desistir completamente de
distribuir o Programa.

Se qualquer parte desta secção for considerada inválida ou não aplicável em
qualquer circunstância particular, o restante da secção aplica-se, e a secção
como um todo aplicar-se-á em outras circunstâncias.

O propósito desta secção não é o de induzi-lo a infringir quaisquer patentes ou
reivindicação de direitos de propriedade de outros, ou a contestar a validade
de quaisquer dessas reivindicações; esta secção tem como único propósito
proteger a integridade dos sistemas de distribuição de software livre, que é
implementado pela prática de licenças públicas. Várias pessoas têm contribuído
generosamente e em grande escala para software distribuído usando este sistema,
na certeza de que sua aplicação é feita de forma consistente; fica a critério
do autor/doador decidir se ele ou ela está disposto(a) a distribuir software
utilizando outro sistema, e um outro detentor de uma licença não pode impor
esta ou qualquer outra escolha.

Esta secção destina-se a tornar bastante claro o que se acredita ser
consequência do restante desta Licença.

8. Se a distribuição e/ou uso do Programa são restringidos em certos países por
patentes ou direitos de autor, o detentor dos direitos de autor original, que
colocou o Programa sob esta Licença, pode incluir uma limitação geográfica de
distribuição, excluindo aqueles países, de forma a apenas permitir a
distribuição nos países não excluídos. Nestes casos, esta Licença incorpora a
limitação como se a mesma constasse escrita nesta Licença.

9. A Free Software Foundation pode publicar versões revistas e/ou novas da
Licença Pública Geral de tempos em tempos. Estas novas versões serão similares
em espírito à versão actual, mas podem diferir em detalhes que resolvam novos
problemas ou situações.

A cada versão é dada um número distinto. Se o Programa especifica um número de
versão específico desta Licença que se aplica a ele e a "qualquer nova versão",
você tem a opção de aceitar os termos e condições daquela versão ou de qualquer
outra versão.
*/

if (ini_get('session.auto_start')==0) 
{
	$profilSession = "";
}

error_reporting(0);
@ini_set("session.use_trans_sid",0);

//disable session on export
if ($export != "true") 
{
	session_start();
}

/** 
 * Wrapper to make sure null strings display as 0 in sql queries
 * @param string $var An integer represented as a string
 **/
function fixInt($var) {
	if ($var == '') {
          return 0;
        } else {
          return $var;
        }
} 

/**
 * Return global variable
 * @param string $var Variable name
 * @param string $type Variable type (SERVER, POST, GET, SESSION, REQUEST, COOKIE)
 * @access public
 **/
function returnGlobal($var,$type)
{
	if (phpversion() >= "4.1.0") 
	{
		if ($type == "SERVER") 
		{
			return $_SERVER[$var];
		}
		if ($type == "POST") 
		{
			return $_POST[$var];
		}
		if ($type == "GET") 
		{
			return $_GET[$var];
		}
		if ($type == "SESSION") 
		{
			return $_SESSION[$var];
		}
		if ($type == "REQUEST") 
		{
			return $_REQUEST[$var];
		}
		if ($type == "COOKIE") 
		{
			return $_COOKIE[$var];
		}
	} 
	else 
	{
		global $$var;
		return $$var;
	}
}

// register_globals cheat code
if (ini_get(register_globals) != "1") 
{
	//GET and POST VARS
	while (list($key, $val) = @each($_REQUEST)) 
	{
		   $GLOBALS[$key] = $val;
	}
	//$HTTP_SESSION_VARS
	while (list($key, $val) = @each($_SESSION))
	{
		   $GLOBALS[$key] = $val;
	}
	//$HTTP_SERVER_VARS
	while (list($key, $val) = @each($_SERVER)) 
	{
		   $GLOBALS[$key] = $val;
	}
}

$msg = returnGlobal('msg','GET');
$session = returnGlobal('session','GET');
$logout = returnGlobal('logout','GET');
$idSession = returnGlobal('idSession','SESSION');
$dateunixSession = returnGlobal('dateunixSession','SESSION');
$loginSession = returnGlobal('loginSession','SESSION');
$profilSession = returnGlobal('profilSession','SESSION');
$logouttimeSession = returnGlobal('logouttimeSession','SESSION');

/**
 * Check last version of SGD
 * @param string $iCV Version to compare
 * @access public
 **/
function updatechecker($iCV) 
{
	global $strings;

	$sVersiondata = join('',file("http://www.SGD.com/website/version.txt"));
	$aVersiondata = explode("|",$sVersiondata);
	$iNV = $aVersiondata[0];
	
	if ($iCV < $iNV) 
	{
		$checkMsg = "<br/><b>".$strings["update_available"]."</b> ".$strings["version_current"]." $iCV. ".$strings["version_latest"]." $iNV.<br/>";
		$checkMsg .= "<a href=\"http://www.sourceforge.net/projects/SGD\" target=\"_blank\">".$strings["sourceforge_link"]."</a>.";
	}
	
	return $checkMsg;
}

/**
 * Calculate time to parse page (used with footer.php)
 * @access public
 **/
function getmicrotime(){
	list($usec, $sec) = explode(" ",microtime());
	return ((float)$usec + (float)$sec);
}
$parse_start = getmicrotime();

//database update array
$updateDatabase = array(0 => "1.0", 1 => "1.1", 2 => "1.3", 3 => "1.4", 4 => "1.6", 5 => "1.8", 6 => "1.9", 7 => "2.0", 8 => "2.1", 9 => "2.5");

//languages array
$langValue = array("en" => "English", "es" => "Spanish", "fr" => "French", "it" => "Italian", "pt" => "Portuguese", "da" => "Danish", "no" => "Norwegian", "nl" => "Dutch", "de" => "German", "zh" => "Chinese simplified", "uk" => "Ukrainian", "pl" => "Polish", "in" => "Indonesian", "ru" => "Russian", "az" => "Azerbaijani", "ko" => "Korean", "zh-tw" => "Chinese traditional", "ca" => "Catalan", "pt-br" => "Brazilian Portuguese", "et" => "Estonian", "bg" => "Bulgarian", "ro" => "Romanian", "hu" => "Hungarian", "cs-iso" => "Czech (iso)", "cs-win1250" => "Czech (win1250)", "is" => "Icelandic", "sk-win1250" => "Slovak (win1250)", "tr" => "Turkish", "lv" => "Latvian", "ar" => "Arabic");

//settings and date selector includes
if ($indexRedirect == "true") 
{
	include('includes/settings.php');
} 
else 
{
	include('../includes/settings.php');
}

if ($langDefault != "") 
{
	$langSelected[$langDefault] = "selected";
} 
else 
{
	$langSelected = "";
}

//fix if update from old version
if ($theme == "") {
	$theme = "default";
}
if (!is_resource(THEME)) {
	define('THEME',$theme);
}
if (!is_resource(FTPSERVER)) {
	define('FTPSERVER','');
}
if (!is_resource(FTPLOGIN)) {
	define('FTPLOGIN','');
}
if (!is_resource(FTPPASSWORD)) {
	define('FTPPASSWORD','');
}
if ($uploadMethod == "") {
	$uploadMethod = "PHP";
}
if ($peerReview == "") {
	$peerReview = "true";
}

if ($loginMethod == "") {
	$loginMethod = "PLAIN";
}
if ($databaseType == "") {
	$databaseType = "mysql";
}
if ($installationType == "") {
	$installationType = "online";
}

//if($enviar=="true"){

include("../includes/email.php");

include("../includes/arquivo.php");

//}

//request data class
if ($indexRedirect == "true") 
{
	include("includes/initrequests.php");
	include("includes/request.class.php");
} 
else 
{
	include("../includes/initrequests.php");
	include("../includes/request.class.php");
}

//layout class
if ($indexRedirect == "true") 
{
		include("themes/".THEME."/block.class.php");
} 
else 
{
	include("../themes/".THEME."/block.class.php");
}


//baner de acordo com o perfil
//if($profilSession == 1){
//$banner_top = "teste_01p.jpg";
//}else{
$banner_top = "teste_01.jpg";
//}

function auto_url(){
global $sor_champs,$sor_ordre,$REQUEST_URI ;
$block1 = new block();

 $url = explode("?",$REQUEST_URI);

 $url2 = explode("/projects/",$url[0]) ; 
 $url3 = explode("/projects_site/",$url[0]) ; 

   if(($url2[1]=='listprojects.php')||($url3[1]=='home.php')){

     if($sor_champs){
    $_SESSION['query'] = $sor_champs." ".$sor_ordre;
     }

   }

}
/**
 * Redirect to specified url
 * @param string $url Path to redirect
 * @access public
 **/
function headerFunction($url) 
{
	header("Location:$url");
}

//language browser detection
if ($langDefault == "") 
{
	if(isset($HTTP_ACCEPT_LANGUAGE)) 
	{
		$plng = split(",", $HTTP_ACCEPT_LANGUAGE);
			if(count($plng) > 0) 
			{
				while(list($k,$v) = each($plng)) 
				{
					$k = split(";", $v, 1);

					$k = split("-", $k[0]);

					if(file_exists("../languages/lang_".$k[0].".php")) 
					{
						$langDefault = $k[0];
						break;
					}
					$langDefault = "en";
				}
			} 
			else 
			{
				$langDefault = "en";
			}
	} 
	else 
	{
		$langDefault = "en";
	}
}

//check session validity on main SGD, except for demo user
if ($checkSession != "false" && $demoSession != "true") 
{
	
	
	if ($profilSession == 30 && !strstr($PHP_SELF,"projects_site")) 
	{
		headerFunction("../projects_site/home.php");
	}

	if ($lastvisitedpage)
	{
		if (!strstr($_SERVER['PHP_SELF'],"graph")) 
		{
				$sidCode = session_name();
				$page = $_SERVER['PHP_SELF']."?".$QUERY_STRING;
				$page = eregi_replace("(&".$sidCode."=)([A-Za-z0-9.]*)($|.)", "", $page); 
				$page = eregi_replace("(".$sidCode."=)([A-Za-z0-9.]*)($|.)", "", $page);
				$page = strrev($page);
				$pieces = explode("/",$page);
				$pieces[0] = strrev($pieces[0]);
				$pieces[1] = strrev($pieces[1]);
				$page = $pieces[1]."/".$pieces[0];
				$tmpquery = "UPDATE ".$tableCollab["members"]." SET last_page='$page' WHERE id = '".fixInt($idSession)."'";
				//connectSql("$tmpquery");
		}
	}
	//if auto logout feature used, store last required page before deconnexion
	if ($profilSession != 30) 
	{
		if ($logouttimeSession != "0" && $logouttimeSession != "") 
		{
			
			
			$dateunix=date("U");
			$diff = $dateunix-$dateunixSession;

			if ($diff > $logouttimeSession) 
			{
				headerFunction("../general/login.php?logout=true");
			} 
			else 
			{
				$dateunixSession=$dateunix;
				if (version_compare("4.1.1", phpversion(),"<") > 0) 
				{
					$_SESSION['dateunixSession'] = $dateunixSession;
				} 
				else 
				{
					session_register("dateunixSession");
				}
			}
		}
	}

	
	
	$tmpquery = "WHERE log.login = '".fixInt($loginSession)."'";
	$checkLog = new request();
	$checkLog->openLogs($tmpquery);

	$comptCheckLog = count($checkLog->log_id);
	if ($comptCheckLog != "0") 
	{
		if (session_id() != $checkLog->log_session[0]) 
		{
				
			headerFunction("../index.php?session=false");
		}
	} 
	else 
	{
		headerFunction("../index.php?session=false");
	}
}

//count connected users
if ($checkConnected != "false") 
{
	$dateunix=date("U");
	//$dateunix=date("YmdHis");
	$tmpquery1 = "UPDATE ".$tableCollab["logs"]." SET connected='$dateunix' WHERE login = '$loginSession'";
	connectSql("$tmpquery1");
	//$tmpsql = "SELECT * FROM ".$tableCollab["logs"]." WHERE connected > '$dateunix-5*60'";
	$tmpsql = "SELECT * FROM ".$tableCollab["logs"]." WHERE connected is not null" ;
	compt($tmpsql);
	$connectedUsers = $countEnregTotal;
}

//redirect if server/database in error
if ($databaseType == "mysql") 
{
	if (!@mysql_connect(MYSERVER,MYLOGIN,MYPASSWORD)) 
	{
		headerFunction("../general/error.php?type=myserver");
		exit;
	} 
	else 
	{
		$res = mysql_connect(MYSERVER,MYLOGIN,MYPASSWORD);
	}
	if (!@mysql_select_db(MYDATABASE,$res)) 
	{
		headerFunction("../general/error.php?type=mydatabase");
		exit;
	} 
	else 
	{
		@mysql_close($res);
	}
}

if ($databaseType == "oracle") 
{
	if (!OCILogon(MYLOGIN,MYPASSWORD,MYSERVER)) 
	{
		headerFunction("../general/error.php?type=myserver");
		exit;
	} 
	else 
	{
		$res = OCILogon(MYLOGIN,MYPASSWORD,MYSERVER);
	}
}

//disable actions if demo user logged in demo mode
if ($action != "") 
{
	if ($demoSession == "true") 
	{
		$closeTopic = "";
		$addToSiteTask = "";
		$removeToSiteTask = "";
		$addToSiteTopic = "";
		$removeToSiteTopic = "";
		$addToSiteTeam = "";
		$removeToSiteTeam = "";

		$action = "";
		$msg = "demo";
	}
}

//set language session
if ($languageSession == "") 
{
	$lang = $langDefault;
} 
else 
{
	$lang = $languageSession;
}


//language include
if ($indexRedirect == "true") 
{
	include("languages/lang_en.php");
	include("languages/lang_".$lang.".php");
	include("languages/help_".$lang.".php");
} 
else 
{
	include("../languages/lang_en.php");
	include("../languages/lang_".$lang.".php");
	include("../languages/help_".$lang.".php");
}

/**
 * Automatic links
 * @param string $data Text to parse
 * @access public
 **/
function autoLinks($data) 
{
	global $newText;
	$lines = explode("\n", $data); 
	while (list ($key, $line) = each ($lines)) 
	{ 
		$line = eregi_replace("([ \t]|^)www\.", " http://www.", $line); 

		$line = eregi_replace("([ \t]|^)ftp\.", " ftp://ftp.", $line); 
		$line = eregi_replace("(http://[^ )\r\n]+)", "<a href=\"\\1\" target=\"_blank\">\\1</a>", $line); 
		$line = eregi_replace("(https://[^ )\r\n]+)", "<a href=\"\\1\" target=\"_blank\">\\1</a>", $line); 
		$line = eregi_replace("(ftp://[^ )\r\n]+)", "<a href=\"\\1\" target=\"_blank\">\\1</a>", $line); 
		$line = eregi_replace("([-a-z0-9_]+(\.[_a-z0-9-]+)*@([a-z0-9-]+(\.[a-z0-9-]+)+))", "<a href=\"mailto:\\1\">\\1</a>", $line); 
		
		if (empty($newText)) 
		{ 
			$newText = $line; 
		} 
		else 
		{ 
			$newText .= "\n$line"; 
		} 
	} 
}

if ($notifications == "true") 
{
	if ($indexRedirect != "true") 
	{
		include("../includes/notification.class.php");
	}
}

/*Retira acentos */
function retira_ac( $texto ) 
{ 

  $union = trim($texto);

  $array1 = array(   "á", "à", "â", "ã", "ä", "é", "è", "ê", "ë", "í", "ì", "î", "ï", "ó", "ò", "ô", "õ", "ö", "ú", "ù", "û", "ü", "ç" 
                     , "Á", "À", "Â", "Ã", "Ä", "É", "È", "Ê", "Ë", "Í", "Ì", "Î", "Ï", "Ó", "Ò", "Ô", "Õ", "Ö", "Ú", "Ù", "Û", "Ü", "Ç" ); 
  $array2 = array(   "a", "a", "a", "a", "a", "e", "e", "e", "e", "i", "i", "i", "i", "o", "o", "o", "o", "o", "u", "u", "u", "u", "c" 
                     , "A", "A", "A", "A", "A", "E", "E", "E", "E", "I", "I", "I", "I", "O", "O", "O", "O", "O", "U", "U", "U", "U", "C" ); 
  return str_replace( $array1, $array2, trim($union) ); 
} 
 
 function remove_var($var)
{
   return($var != "");
}
 
 
 /* Remove indice com values vazio  */
 function array_clear($array){
 $novo_array = array();
 
 /* Chama função remover variavel remove_var()*/
 $redu_array = array_filter($array, "remove_var");
 $result_array = array_merge($novo_array,  $redu_array);
 
 return  $result_array;
  	
 }
 
 
/*Iinverte a data para padrao pt-br  retorna mod. 2006-02-15*/
function data_invert($data){
$dia = substr("$data", 0, 2);
$mes = substr("$data", 3, 2);
$ano = substr("$data", 6, 4);

$v = $data ;
$v = substr($v,4,1);
if($v == "-" ){
	if($ano==""){
	$data_pt = " ";
	}else{
	$data_pt = $data ;
	}
}else{

		
		$h = substr("$data", 11, 5);
			if(!$h==""){
				if($ano  <= 0 ){
				$data_pt = " ";
				}else{
				$data_pt = $ano."-".$mes."-".$dia." ".$h;
				}
			}else{
				if($ano <= 0 ){
				$data_pt = " ";
				}else{
				$data_pt = $ano."-".$mes."-".$dia;
				}
			}
	 }

return $data_pt;
}


 /*Iinverte a data para padrao pt-br retorna mod. 15-02-2006 */
function invert_data($data){
$ano = substr("$data", 0, 4);
$mes = substr("$data", 5, 2);
$dia = substr("$data", 8, 2);
$h = substr("$data", 11, 5);
	if(!$h==""){
		if($ano <= 0 ){
		$data_pt = " ";
		}else{
		$data_pt = $dia."-".$mes."-".$ano." ".$h;
		}
	}else{
		if($ano <= 0 ){
		$data_pt = " ";
		}else{
		$data_pt = $dia."-".$mes."-".$ano;
		}
	}

return $data_pt;
}

function mostra_mes($data,$ano){
global $monthNameArray;

if(count($data)==10){

$mes = substr("$data", 5, 2);
$mesp = substr("$data", 5, 1);

}

if($mesp==0){

$mes = substr("$data", 6, 1);

}

if($ano!=""){
$ano = substr("$data", 0, 4);

$result = $monthNameArray[$mes]." - ".$ano;

}else{

$result = $monthNameArray[$mes];

}

return $result;

}

function proximoct($mes,$ano){
	if($mes==12){
	$mes_atual = "01";
	$ano_atual = $ano + 1;
	}else{
	$mes_atual = $mes + 1 ;
	$ano_atual = $ano ;
	if($mes_atual <= 9 ){
	$mes_atual = "0".$mes_atual;
	}
	
	}
	
	return $ano_atual."-".$mes_atual."-".date('d');

}
//
function anteriorct($mes,$ano){
	if($mes==1){
	$mes_atual = "12";
	$ano_atual = $ano - 1;
	}else{
	$mes_atual = $mes - 1 ;
	$ano_atual = $ano ;
	if($mes_atual <= 9 ){
	$mes_atual = "0".$mes_atual;
	}
	
	}
	
	return $ano_atual."-".$mes_atual."-".date('d');

}


//informa hora de acordo com o dia informado 
function mostra_dia($texto,$prodata,$prohora,$cont1,$cont2){

$valido = "&nbsp;";

for($i=0 ; $i < count($prodata); $i++){
$diaa = $prodata[$i];
$ano = substr("$diaa", 0, 4);
$mes = substr("$diaa", 5, 2);
$dia = substr("$diaa", 8, 2);

$dia_real = date(" l ", mktime(0, 0, 0, $mes, $dia, $ano));

	if(($dia >= $cont1) && ($dia <= $cont2)){
		if(trim($dia_real) == trim($texto)){
		//pega hora
		//echo $valido = "<span title='".$texto."-".$dia_real."'>".$reqPro->recpro_hora[$i]."</span>";
		$valido = "<span title='".$dia."-".$mes."-".$ano." Utiliza:".$prohora[$i]."h ' style='cursor:hand;'>".$prohora[$i]."</span>";
		}
	}
}


return $valido ;

}
//

 /*Iinverte a data para padrao pt-br */
function fase_status($data1,$data2,$data3,$data4,$st=0){

if($data1=="" || $data2=="" || $data3=="" || $data4==""){

$situacao = 1;

}else{ 
	if(($data1==$data2) && ($data3==$data4)){
	$situacao = "2";
	}else{
	//Primeira data 
	$ano1 = substr("$data1", 0, 4);
	$mes1 = substr("$data1", 5, 2);
	$dia1 = substr("$data1", 8, 2);
	
	$data_pt1 = $ano1.$mes1.$dia1;
	//echo "<br>";
	//Segunda data
	$ano2 = substr("$data2", 0, 4);
	$mes2 = substr("$data2", 5, 2);
	$dia2 = substr("$data2", 8, 2);
	
	 $data_pt2 = $ano2.$mes2.$dia2;
	//echo "<br>";
	//terceira data
	$ano3 = substr("$data3", 0, 4);
	$mes3 = substr("$data3", 5, 2);
	$dia3 = substr("$data3", 8, 2);
	
	 $data_pt3 = $ano3.$mes3.$dia3;
	//echo "<br>";
	//quarta data
	$ano4 = substr("$data4", 0, 4);
	$mes4 = substr("$data4", 5, 2);
	$dia4 = substr("$data4", 8, 2);
	
	$data_pt4 = $ano4.$mes4.$dia4;
	
	//echo "<br>";
	$plan_data = $data_pt2 - $data_pt1 ;
	//echo "<br>";
	
	 $real_data = $data_pt4 - $data_pt3 ;
	//echo "<br>";
	 if($real_data== "0"){
	 $real_data = 1;
	 }

	
	$realizado = (($real_data * 100) / $plan_data ) / 100;
	 
	$idd = floatval($realizado) ;
	//
		
	if(($idd >= 0.90 && $idd <= 1.00)||($idd <= 1.10 && $idd >= 1.00)){ $situacao = "2"; } 
	if(($idd < 0.90 && $idd >= 0.80)||($idd < 1.20 && $idd >= 1.10)){ $situacao = "3"; } 
	if(($idd < 0.80)||($idd > 1.20 )){ $situacao = "5"; } 
	
	}
	 $test_dt = date('Ymd');
	 if(($st!=2) && ($test_dt > $data_pt4)){
	 $situacao = "3";
	 }
}

//echo "situação: ---> ".$situacao."<br>st :".$st." valor idd:".$idd;

return $situacao;

}


/**
 * Return number of day between 2 dates
 * @param string $date1 Date to compare
 * @param string $date2 Date to compare
 * @access public
 **/
function diff_date($date1, $date2)
{
	$an = substr("$date1", 0, 4);
	$mois = substr("$date1", 5, 2);
	$jour = substr("$date1", 8, 2);

	$an2 = substr("$date2", 0, 4);
	$mois2 = substr("$date2", 5, 2);
	$jour2 = substr("$date2", 8, 2);

	$timestamp = mktime(0, 0, 0, $mois, $jour, $an); 
	$timestamp2 = mktime(0, 0, 0, $mois2, $jour2, $an2); 
  	$diff = floor(($timestamp - $timestamp2) / (3600 * 24)); 
	return $diff; 
}

/**
 * Checks for password match using the globally specified login method
 * @param string $formUsername User name to test
 * @param string $formPassword User name password to test
 * @param string $storedPassword Password stored in database
 * @access public
 **/
function is_password_match($formUsername, $formPassword, $storedPassword ) 
{
	global $loginMethod, $useLDAP, $configLDAP;
	
	if($useLDAP == "true")
	{
		if($formUsername == "admin")
		{
			switch ($loginMethod) 
			{
				case MD5:	
					if (md5($formPassword) == $storedPassword) 
					{
						return true;
					} 
					else 
					{
						return false;
					}
				case CRYPT:	
					$salt = substr($storedPassword, 0, 2 );
					if (crypt($formPassword,$salt) == $storedPassword) 
					{
						return true;
					} 
					else 
					{
						return false;
					}
				case PLAIN:	
					if ($formPassword == $storedPassword) 
					{
						return true;
					} 
					else 
					{
						return false;
					}
				return false;
			}
		}
		$conn = ldap_connect($configLDAP[ldapserver]);
		$sr = ldap_search($conn, $configLDAP[searchroot], "uid=$formUsername");
		$info = ldap_get_entries($conn, $sr);
		$user_dn = $info[0]["dn"];
		if(!$bind = @ldap_bind($conn, $user_dn, $formPassword))
			return false;	
		else
			return true;
	}
	else
	{
	switch ($loginMethod) 
		{
			case MD5:	
				if (md5($formPassword) == $storedPassword) 
				{
					return true;
				} 
				else 
				{
					return false;
				}

			case CRYPT:	
				$salt = substr($storedPassword, 0, 2 );
				if (crypt($formPassword,$salt) == $storedPassword) 
				{
					return true;
				} 
				else 
				{
					return false;
				}

			case PLAIN:	
				if ($formPassword == $storedPassword) 
				{
					return true;
				} 
				else 
				{
					return false;
				}
			
			return false;
		}
	}
}

/**
 * Return a password using the globally specified method
 * @param string $newPassword Password to transfom
 * @access public
 **/
function get_password($newPassword) 
{
	global $loginMethod;

	switch ($loginMethod) 
	{
		case MD5:	
				return md5($newPassword);
		case CRYPT:	
				$salt = substr($newPassword,0,2);
				return crypt($newPassword,$salt);
		case PLAIN:	
				return $newPassword;

		return $newPassword;
	}
}

/**
 * Generate a random password
 * @param string $size Size of geenrated password
 * @param boolean $with_numbers Option to use numbers
 * @param boolean $with_tiny_letters Option to use tiny letters
 * @param boolean $with_capital_letters Option to use capital letters
 * @access public
 **/
function password_generator($size=8, $with_numbers=true, $with_tiny_letters=true, $with_capital_letters=true) 
{ 
	global $pass_g;

	$pass_g = ""; 
	$sizeof_lchar = 0; 
	$letter = ""; 
	$letter_tiny = "abcdefghijklmnopqrstuvwxyz"; 
	$letter_capital = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; 
	$letter_number = "0123456789";

	if($with_tiny_letters == true)
	{ 
		$sizeof_lchar += 26; 
		if (isset($letter)) 
		{
			$letter .= $letter_tiny; 
		}
		else 
		{
			$letter = $letter_tiny; 
		}
	} 

	if($with_capital_letters == true)
	{ 
		$sizeof_lchar += 26; 
		if (isset($letter))
		{
			$letter .= $letter_capital; 
		}
		else
		{
			$letter = $letter_capital; 
		}
	} 

	if($with_numbers == true)
	{ 
		$sizeof_lchar += 10; 
		if (isset($letter))
		{
			$letter .= $letter_number; 
		}
		else 
		{
			$letter = $letter_number; 
		}
	} 

	if($sizeof_lchar > 0)
	{ 
		srand((double)microtime()*date("YmdGis")); 
		for($cnt = 0; $cnt < $size; $cnt++)
		{ 
			$char_select = rand(0, $sizeof_lchar - 1); 
			$pass_g .= $letter[$char_select]; 
		} 
	} 

	return $pass_g; 
}

/**
 * Move a file in a new destination
 * @param string $source Current path of file
 * @param string $dest New path of file
 * @access public
 **/
function moveFile($source, $dest) 
{
	global $mkdirMethod,$ftpRoot;

	if($mkdirMethod == "FTP") 
	{
		$ftp = ftp_connect(FTPSERVER);
		ftp_login($ftp,FTPLOGIN,FTPPASSWORD);
		ftp_rename($ftp, "$ftpRoot/$source", "$ftpRoot/$dest");
		ftp_quit($ftp);
	} 
	else 
	{
		copy("../".$source, "../".$dest);
	}
}

/**
 * Delete a file with a specified path
 * @param string $source Path of file
 * @access public
 **/
function deleteFile($source) 
{
	global $mkdirMethod,$ftpRoot;

	if($mkdirMethod == "FTP") 
	{
		$ftp = ftp_connect(FTPSERVER);
		ftp_login($ftp,FTPLOGIN,FTPPASSWORD);
		ftp_delete($ftp, $ftpRoot."/".$source);
		ftp_quit($ftp);
	} 
	else 
	{
		unlink("../".$source);
	}
}

/**
 * Upload a file to a specified destination
 * @param string $path Path of original file
 * @param string $source Temp file
 * @param string $dest Destination path
 * @access public
 **/
function uploadFile($path, $source, $dest) 
{
	global $mkdirMethod,$ftpRoot;

	$pathNew = $ftpRoot."/".$path;

	if (!file_exists($pathNew))
	{
			# if there is no project dir first create it
			$path_info = pathinfo($path);
			if ( $path != 'files/'.$path_info['basename'])
			{
					createDir($path_info['dirname']);
					createDir($path);
			} 
			else 
			{
					createDir($path);
			}
	} 


	if($mkdirMethod == "FTP") 
	{
		$ftp = ftp_connect(FTPSERVER);
		ftp_login($ftp,FTPLOGIN,FTPPASSWORD);
		ftp_chdir($ftp, $pathNew);
		ftp_put($ftp, $dest, $source, FTP_BINARY);
		ftp_quit($ftp);
	} 
	else 
	{
		@move_uploaded_file($source, "../".$path."/".$dest);
	}
}

/**
 * Folder creation
 * @param string $path Path to the new directory
 * @access public
 **/
function createDir($path) 
{
	global $mkdirMethod,$ftpRoot;

	if ($mkdirMethod == "FTP") 
	{
		$pathNew = $ftpRoot."/".$path;

		$ftp = ftp_connect(FTPSERVER);
		ftp_login($ftp,FTPLOGIN,FTPPASSWORD);
		
		//if (!file_exists($pathNew))
		//{
			ftp_mkdir ($ftp,$pathNew);
		//}
		
		ftp_quit ($ftp);
	}
	
	if ($mkdirMethod == "PHP") 
	{
		@mkdir("../$path",0755);
		@chmod("../$path",0777);
	}
}

/**
 * Folder recursive deletion
 * @param string $location Path of directory to delete
 * @access public
 **/
function delDir($location) 
{ 
	if(is_dir($location)) 
	{
		$all = opendir($location); 
		while ($file = readdir($all)) 
		{ 
			if (is_dir("$location/$file") && $file !=".." && $file!=".") 
			{ 
				deldir("$location/$file"); 
				if(file_exists("$location/$file")){@rmdir("$location/$file"); }
				unset($file); 
			} 
			else if (!is_dir("$location/$file")) 
			{ 
				if(file_exists("$location/$file")){@unlink("$location/$file"); }
				unset($file); 
			} 
		} 
		closedir($all);
		@rmdir($location);
	} 
	else 
	{
		if(file_exists("$location")) {@unlink("$location");}
	}
}

/**
 * Return recursive folder size
 * @param string $location Path of directory to calculate
 * @param boolean $recursive Option to use recursivity
 * @access public
 **/
function folder_info_size($path, $recursive=TRUE) 
{ 
	$result = 0; 
	if (is_dir($path) || is_readable($path)) 
	{
		$dir = opendir($path); 
		while($file = readdir($dir))
		{
			if ($file != "." && $file != "..") 
			{
				if (@is_dir("$path$file/")) 
				{
					$result += $recursive?folder_info_size("$path$file/"):0; 
				} 
				else 
				{
					$result += filesize("$path$file"); 
				} 
			}
		} 
		
		closedir($dir);
		return $result;
	} 
}

/**
 * Return size converted with units (in the user language)
 * @param string $result Result to convert
 * @access public
 **/
function convertSize($result) 
{
	global $byteUnits;
	
	if ($result >= 1073741824) 
	{
		$result = round($result / 1073741824 * 100) / 100 . " ".$byteUnits[3];
	} 
	else if ($result >= 1048576) 
	{
		$result = round($result / 1048576 * 100) / 100 . " ".$byteUnits[2];
	} 
	else if ($result >= 1024) 
	{
		$result = round($result / 1024 * 100) / 100 . " ".$byteUnits[1];
	} 
	else 
	{
		$result = $result . " ".$byteUnits[0];
	}
	
	if($result==0) 
	{
		$result="-";
	}
	
	return $result;
}

/**
 * Return file size
 * @param string $fichier File used
 * @access public
 **/
function file_info_size($fichier) 
{
	global $taille;

	$taille = filesize($fichier);
	return $taille;
}

/**
 * Return file dimensions
 * @param string $fichier File used
 * @access public
 **/
function file_info_dim($fichier) 
{ 
	global $dim; 
	
	$temp = GetImageSize($fichier); 
	$dim = ($temp[0])."x".($temp[1]); 
	return $dim; 
} 

/**
 * Return file date
 * @param string $fichier File used
 * @access public
 **/
function file_info_date($file) 
{
	global $dateFile;

	$dateFile = date("Y-m-d",filemtime($file));
	return $dateFile;
}

/**
 * Read the content of a file
 * @param string $file File used
 * @access public
 **/
function recupFile($file) 
{
	if(!file_exists($file)) 
	{
		echo "File does not exist : " . $file;
			return false;
	}

	$fp = fopen ($file, "r");

	if(!$fp) 
	{
		echo "Unable to open file : " . $file;
		return false;
	}

	while (!feof ($fp)) 
	{
		$tmpline = fgets($fp, 4096);
		$content .= $tmpline;
	}

	fclose($fp);
	return $content;
}

//provide id session if trans_sid false on server (if $trans_sid true in settings)
if ($trans_sid == "true") 
{
	global $transmitSid;
	$transmitSid = session_name()."=".session_id();
}

//time variables
if ($gmtTimezone == "true") 
{
	//$date = gmdate("Y-m-d");
	//$dateheure = gmdate("Y-m-d H:i");
} 
else 
{
	//$date = date("Y-m-d");
	//$dateheure = date("Y-m-d H:i");
}

/**
 * Displat date according to timezone (if timezone enabled)
 * @param string $storedDate Date stored in database
 * @param string $gmtUser User timezone 
 * @access public
 **/
function createDate($storedDate, $gmtUser) 
{
	global $gmtTimezone;

	if ($gmtTimezone == "true") 
	{
		if ($storedDate != "") 
		{
			$extractHour = substr("$storedDate", 11, 2);
			$extractMinute = substr("$storedDate", 14, 2);
			$extractYear = substr("$storedDate", 0, 4);
			$extractMonth = substr("$storedDate", 5, 2);
			$extractDay = substr("$storedDate", 8, 2);

			return date("d-m-Y H:i", mktime($extractHour + $gmtUser,$extractMinute,'',$extractMonth,$extractDay,$extractYear));
		}
	} 
	else 
	{
		return $storedDate;
	}
}

//update sorting table if query sort column
//if (!empty($sor_cible) && $sor_cible != "" && $sor_champs != "none") 
//{
//	$sor_champs = convertData($sor_champs);
//	$sor_cible = convertData($sor_cible);

//	$tmpquery = "UPDATE ".$tableCollab["sorting"]." SET $sor_cible='$sor_champs $sor_ordre' WHERE member = '$idSession'";
//	connectSql("$tmpquery");
//}

//set all sorting values for logged user
//$tmpquery = "WHERE sor.member = '".fixInt($idSession)."'";
//$sortingUser = new request();
//$sortingUser->openSorting($tmpquery);

/**
 * Convert insert data value in form
 * @param string $data Data to convert
 * @access public
 **/
function convertData($data) 
{
	global $databaseType;
	
	if ($databaseType == "sqlserver") 
	{
		$data = str_replace('"','&quot;',$data);
		$data = str_replace("'",'&#39;',$data);
		$data = str_replace('<','&lt;',$data);
		$data = str_replace('>','&gt;',$data);
		$data = stripslashes($data);
		return ($data);
	} 
	elseif (get_magic_quotes_gpc() == 1) 
	{
		$data = str_replace('"','&quot;',$data);
		$data = str_replace('<','&lt;',$data);
		$data = str_replace('>','&gt;',$data);
		$data = str_replace("'",'&#39;',$data);
		return ($data);
    } 
	else 
	{
		$data = str_replace('"','&quot;',$data);
		$data = str_replace('<','&lt;',$data);
		$data = str_replace('>','&gt;',$data);
		$data = str_replace("'",'&#39;',$data);
		$data = addslashes($data);
		return ($data);
	}

}

/**
 * Count total results from a request
 * @param string $tmpsql Sql query
 * @access public
 **/
function compt($tmpsql) {
	global $tableCollab,$databaseType,$countEnregTotal,$comptRequest;

	$comptRequest = $comptRequest + 1;

	if ($databaseType == "mysql") {
		$res = mysql_connect(MYSERVER,MYLOGIN,MYPASSWORD) or die($strings["error_server"]);
		mysql_select_db(MYDATABASE,$res) or die($strings["error_database"]);
		$sql = "$tmpsql";
		$index = mysql_query($sql, $res);
		
		while($row = @mysql_fetch_row($index)) {
			$countEnreg[] = ($row[0]);
		}
		
		$countEnregTotal = count($countEnreg);
		@mysql_free_result($index);
		@mysql_close($res);
	}

	if ($databaseType == "postgresql") {
		$res = pg_connect("host=".MYSERVER." port=5432 dbname=".MYDATABASE." user=".MYLOGIN." password=".MYPASSWORD);
		$sql = "$tmpsql";
		$index = pg_query($res,$sql);
		
		while($row = pg_fetch_row($index)) {
			$countEnreg[] = ($row[0]);
		}	
		
		$countEnregTotal = count($countEnreg);
		@pg_free_result($index);
		@pg_close($res);
	}

	if ($databaseType == "sqlserver") {
	 
		$res = mssql_connect(MYSERVER,MYLOGIN,MYPASSWORD) or die($strings["error_server"]);
		mssql_select_db(MYDATABASE,$res) or die($strings["error_database"]);
		$sql = "$tmpsql";
		$index = mssql_query($sql, $res);
		
		while($row = mssql_fetch_row($index)) {
			$countEnreg[] = ($row[0]);
		}

		$countEnregTotal = count($countEnreg);
		@mssql_free_result($index);
		@mssql_close($res);
	 
	}
	if ($databaseType == "oracle") {

		$res = OCILogon(MYLOGIN,MYPASSWORD,MYSERVER) or die($strings["error_server"]);
		$sql = "$tmpsql";

		$index = @OCIParse($res,$sql);
		
		OCIExecute($index) or die ("Erro na Seleção dos Dados no Oracle=Library.php".$tmpsql);

		while(OCIFetch($index)) {
			$countEnreg[] = ($row[0]);
		}

		$countEnregTotal = count($countEnreg);
		
		OCIFreeStatement($index);
		OCILogOff($res);

	}
	return $countEnregTotal;
}

/**
 * Simple query
 * @param string $tmpsql Sql query
 * @access public
 **/
function connectSql($tmpsql) {
global $tableCollab,$databaseType;
	
	if ($databaseType == "mysql") {
		$res = mysql_connect(MYSERVER,MYLOGIN,MYPASSWORD) or die($strings["error_server"]);
		mysql_select_db(MYDATABASE,$res) or die($strings["error_database"]);
		$sql = $tmpsql;
		$index = mysql_query($sql);
		@mysql_free_result($index);
		@mysql_close($res) ;
	}
	if ($databaseType == "postgresql") {
		$res = pg_connect("host=".MYSERVER." port=5432 dbname=".MYDATABASE." user=".MYLOGIN." password=".MYPASSWORD);
		$sql = $tmpsql;
		$index = pg_query($res,$sql);
		@pg_free_result($index);
		@pg_close($res) ;
	}
	if ($databaseType == "sqlserver") {
		$res = mssql_connect(MYSERVER,MYLOGIN,MYPASSWORD) or die($strings["error_server"]);
		mssql_select_db(MYDATABASE,$res) or die($strings["error_database"]);
		$sql = $tmpsql;
		$index = mssql_query($sql, $res);
		@mssql_free_result($index);
		@mssql_close($res) ;
	}
	if ($databaseType == "oracle") {
		$res = OCILogon(MYLOGIN,MYPASSWORD,MYSERVER);
		$sql = $tmpsql;
		$index = @OCIParse($res,$sql);
		@OCIExecute($index);
		OCIFreeStatement($index);
		OCILogOff($res);
	}
}

/**
 * Captura Telefone
 **/
function telefone_pg($id){
global $tableCollab,$databaseType;
if ($databaseType == "oracle") {
			$res = OCILogon(MYLOGIN,MYPASSWORD,MYSERVER);
			
			$sql = "SELECT PHONE_WORK FROM ".MYDATABASE.".members WHERE id='".$id."' ";
			$index = OCIParse($res,$sql);
			OCIExecute($index);
			
   $nrows = ocifetchstatement($index, $results);
   $phone_work = $results["PHONE_WORK"][0];
   
			
		OCIFreeStatement($index);
		OCILogOff($res);
	}


return  $phone_work ;

}
//


/**
 * Return last id from any table
 * @param string $tmpsql Table name
 * @access public
 **/
function last_id($tmpsql) {
	global $tableCollab,$databaseType;
	if ($databaseType == "mysql") {
		$res = mysql_connect(MYSERVER,MYLOGIN,MYPASSWORD) or die($strings["error_server"]);
		mysql_select_db(MYDATABASE,$res) or die($strings["error_database"]);
		global $lastId;
		$sql = "SELECT id FROM $tmpsql ORDER BY id DESC";
		$index = mysql_query($sql,$res);
		while($row = mysql_fetch_row($index)) {
			$lastId[] = ($row[0]);
		}
		@mysql_free_result($index);
		@mysql_close($res);
	}
	if ($databaseType == "postgresql") {
			$res = pg_connect("host=".MYSERVER." port=5432 dbname=".MYDATABASE." user=".MYLOGIN." password=".MYPASSWORD);
			global $lastId;
			$sql = "SELECT id FROM $tmpsql ORDER BY id DESC";
			$index = pg_query($res,$sql);
			while($row = pg_fetch_row($index)) {
			$lastId[] = ($row[0]);
			}
		@pg_free_result($index);
		@pg_close($res);
	}
	if ($databaseType == "sqlserver") {
		$res = mssql_connect(MYSERVER,MYLOGIN,MYPASSWORD) or die($strings["error_server"]);
		mssql_select_db(MYDATABASE,$res) or die($strings["error_database"]);
		global $lastId;
		$sql = "SELECT id FROM $tmpsql ORDER BY id DESC";
		$index = mssql_query($sql,$res);
		while($row = mssql_fetch_row($index)) {
			$lastId[] = ($row[0]);
		}
		@mssql_free_result($index);
		@mssql_close($res);
	}
	if ($databaseType == "oracle") {
			$res = OCILogon(MYLOGIN,MYPASSWORD,MYSERVER);
			global $lastId;
			$sql = "SELECT ID FROM $tmpsql ORDER BY ID DESC";
			$index = OCIParse($res,$sql);
			OCIExecute($index);
			//while($row = OCIFetch($index)) {
			//$lastId[] = ($row[0]);
			//echo "<br>id--".$lastId[0];
			//}
//
   $nrows = ocifetchstatement($index, $results);
   $lastId[] = $results["ID"][0];
   

  /*  for ($i = 0; $i < $nrows; $i++ )
    {
      echo "\n";
      echo "--" . $results["ID"][$i] . "--";
     
    } */
//
			
			
		OCIFreeStatement($index);
		OCILogOff($res);
	}
	
}

//recompute number of completed tasks of the project
// Do it only if the project name contains [ / ]
//list tasks of the same project and count the number of completed
function projectComputeCompletion($projectDetail, $tableProject) {
	 $prj_name = $projectDetail->pro_name[0];
	 preg_match("/\[([0-9 ]*\/[0-9 ]*)\]/", $prj_name, $findit);;
	 if ($findit[1] != "") {
		 $prj_id = $projectDetail->pro_id[0];
		 $taskDetails = new request();
		 $tmpquery = "WHERE tas.project = '$prj_id'";
		 $taskDetails->openTasks($tmpquery);
		 $tasksNumb = count($taskDetails->tas_id);
		 $tasksCompleted = 0;
		 foreach ($taskDetails->tas_status as $stat) {
		 if ($stat == 1) $tasksCompleted++;
		 }
		 $prj_name = preg_replace ("/\[[0-9 ]*\/[0-9 ]*\]/", "[ $tasksCompleted / $tasksNumb ]", $prj_name);
		 $tmpquery5 = "UPDATE ".$tableProject." SET name='$prj_name' WHERE id = '$prj_id'";
		 $ad = connectSql($tmpquery5);
	 }
	 return $prj_name;
}

//compute the average completion of all subtaks of a task
//update the main task completion
//24/05/03: Florian DECKERT
function taskComputeCompletion ($taskid, $tableTask)
{
 $tmpquery = "WHERE subtas.tasks = '$taskid'";
 $subtaskList = new request();
 $subtaskList->openAvgTasks($taskid);
 $avg = $subtaskList->tas_avg[0];
 settype ($avg, "integer");
 $tmpquery6 = "UPDATE ".$tableTask." set completion = $avg where id='$taskid'";
 connectSql($tmpquery6);
}

/**
* check a file name and remove backslash and spaces
* this function remove also the file path if IE is used for upload
* @param string $name the name of the file
*/
function check_FileName($name='') {

 	$name = str_replace('\\', '/', $name);
  	$name = str_replace(" ", "_", $name);
  	
 	if (get_magic_quotes_gpc()) 
 	{
 		$name = basename(stripslashes($name));
    } 
    else 
    {
		$name = basename($name);
	}

    return $name;
}


function yearProjects() {
	global $tableCollab,$databaseType;
	$years = new request();

	if ($databaseType == "mysql") {	   
		$arg = "year(pro.CREATED)";
		$sql = "GROUP BY ($arg)";
		$years->openProjects($sql);
		for ($i=0;$i<count($years->pro_id);$i++) {
			$no_ano[] = substr($years->pro_created[$i],0,4);
		}
	} 
	if ($databaseType == "postgresql") {
		$arg = "year(pro.CREATED)";
		$sql = "GROUP BY ($arg)";
		$years->openProjects($sql);
		for ($i=0;$i<count($years->pro_id);$i++) {
			$no_ano[] = substr($years->pro_created[$i],0,4);
		}
	}	
	if ($databaseType == "sqlserver") {
		$arg = "year(pro.CREATED)";
		$sql = "GROUP BY ($arg)";
		$years->openProjects($sql);
		for ($i=0;$i<count($years->pro_id);$i++) {
			$no_ano[] = substr($years->pro_created[$i],0,4);
		}
	}
	if ($databaseType == "oracle") {
		$arg = "TO_CHAR(TO_DATE(CREATED,'YYYY/MM/DD HH24:MI:SS'),'YYYY')";
		$sql = "GROUP BY ($arg)";
		$years->openProjects($sql);
		for ($i=0;$i<count($years->pro_id);$i++) {
			$no_ano[] = substr($years->pro_created[$i],0,4);
		}
	}	
	return $no_ano;
}

function chamaDataFormtDB($param) {
	global $tableCollab,$databaseType;

	if ($param == 1) {
		if ($databaseType == 'oracle')
			$args = "TO_CHAR(TO_DATE(pro.CREATED,'YYYY/MM/DD HH24:MI:SS'),'YYYY')";
		elseif ($databaseType == 'mysql')
			$args = "year(pro.CREATED)";
		elseif ($databaseType == 'postgresql')
			$args = "TO_CHAR(TO_DATE(pro.CREATED,'YYYY/MM/DD HH24:MI:SS'),'YYYY')";
		elseif ($databaseType == 'sqlserver')
			$args = "TO_CHAR(TO_DATE(pro.CREATED,'YYYY/MM/DD HH24:MI:SS'),'YYYY')";
	}

	if ($param == 2) {
		if ($databaseType == 'oracle')
			$args = "TO_CHAR(TO_DATE(pro.CREATED,'YYYY/MM/DD HH24:MI:SS'),'MM')";
		elseif ($databaseType == 'mysql')
			$args = "month(pro.CREATED)";
		elseif ($databaseType == 'postgresql')
			$args = "TO_CHAR(TO_DATE(pro.CREATED,'YYYY/MM/DD HH24:MI:SS'),'MM')";
		elseif ($databaseType == 'sqlserver')
			$args = "TO_CHAR(TO_DATE(pro.CREATED,'YYYY/MM/DD HH24:MI:SS'),'MM')";
	}
	return $args;
}


// :-)
$setCopyright = "<!-- Powered by SGD v$version //-->";
?>