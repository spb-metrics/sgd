<?php
/*
LICENÇA PÚBLICA GERAL GNU
Versão 2, junho de 1991

Copyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass Ave,
Cambridge, MA 02139, USA

A qualquer pessoa é permitido copiar e distribuir cópias deste documento de
licença, desde que sem qualquer alteração.

Introdução

As licenças de software são normalmente desenvolvidas para restringir a
liberdade de compartilhá-lo e modifica-lo. Pelo contrário, a Licença Pública
Geral GNU pretende garantir a sua liberdade de compartilhar e modificar o
software livre -- garantindo que o software será livre para os seus
utilizadores. Esta Licença Pública Geral aplica-se à maioria do software da
Free Software Foundation e a qualquer outro programa ao qual o seu autor decida
aplicá-la. (Algum software da FSF é cobertos pela Licença Pública Geral de
Bibliotecas.) Também poderá aplicá-la aos seus programas.

Quando nos referimos a software livre, estamo-nos a referir à liberdade e não
ao preço. A Licença Pública Geral (GPL - General Public Licence - em Inglês.)
foi desenvolvida para garantir a sua liberdade de distribuir cópias de software
livre (e cobrar por isso, se quiser); receber o código-fonte ou ter acesso a
ele, se quiser; poder modificar o software ou utilizar partes dele em novos
programas livres; e que saiba que está no seu direito de o fazer.

Para proteger seus direitos, precisamos fazer restrições que impeçam a qualquer
um negar estes direitos ou solicitar que você abdique deles. Estas restrições
traduzem-se em certas responsabilidades para si, caso venha a distribuir cópias
do software, ou modificá-lo.

Por exemplo, se você distribuir cópias de um programa sobre este tipo de
licenciamento, gratuitamente ou por alguma quantia, tem que fornecer igualmente
todos os direitos que possui sobre ele. Tem igualmente que garantir que os
destinatários recebam ou possam obter o código-fonte. Além disto, tem que
fornecer-lhes estes termos para que possam conhecer seus direitos.

Nós protegemos seus direitos por duas formas que se completam: (1) com
copyright do software e (2) com a oferta desta licença, que lhe dá permissão
legal para copiar, distribuir e/ou modificar o software.

Além disso, tanto para a protecção do autor quanto a nossa, gostaríamos de
certificar-nos de que todos entendam que não há qualquer garantia sobre o
software livre. Se o software é modificado por alguém e redistribuído, queremos
que seus destinatários saibam que o que eles obtiveram não é original, de forma
que qualquer problema introduzido por terceiros não interfira na reputação do
autor original.

Finalmente, qualquer programa é ameaçado constantemente por patentes de
software. Queremos evitar o perigo de que distribuidores de software livre
obtenham patentes individuais sobre o software, o que teria o efeito de tornar
o software proprietário. Para prevenir isso, deixamos claro que qualquer
patente tem que ser licenciada para uso livre e gratuito por qualquer pessoa,
ou então que nem necessite ser licenciada.

Os termos e condições precisas para cópia, distribuição e modificação
encontram-se abaixo:

LICENÇA PÚBLICA GERAL GNU TERMOS E CONDIÇÕES PARA CÓPIA, DISTRIBUIÇÃO E
MODIFICAÇÃO

0. Esta licença aplica-se a qualquer programa ou outro trabalho que contenha um
aviso colocado pelo detentor dos direitos autorais informando que aquele pode
ser distribuído sob as condições desta Licença Pública Geral. O "Programa"
abaixo refere-se a qualquer programa ou trabalho e "trabalho baseado no
Programa" significa tanto o Programa em si, como quaisquer trabalhos derivados,
de acordo com a lei de direitos de autor: isto quer dizer um trabalho que
contenha o Programa ou parte dele, tanto na forma original ou modificado, e/ou
tradução para outros idiomas. ***(Doravante o termo "modificação" ou sinónimos
serão usados livremente.) *** Cada licenciado é mencionado como "você".

Actividades outras que a cópia, a distribuição e modificação não estão cobertas
por esta Licença; elas estão fora do seu âmbito. O acto de executar o Programa
não é restringido e o resultado do Programa é coberto pela licença apenas se o
seu conteúdo contenha trabalhos baseados no Programa (independentemente de
terem sido gerados pela execução do Programa). Este último ponto depende das
funcionalidades específicas de cada programa.

1. Você pode copiar e distribuir cópias fiéis do código-fonte do Programa da
mesma forma que você o recebeu, usando qualquer meio, deste que inclua em cada
cópia um aviso de direitos de autor e uma declaração de inexistência de
garantias; mantenha intactos todos os avisos que se referem a esta Licença e à
ausência total de garantias; e forneça aos destinatários do Programa uma cópia
desta Licença, em conjunto com o Programa.

Você pode cobrar pelo acto físico de transferir uma cópia e pode,
opcionalmente, oferecer garantias em troca de pagamento.

2. Você pode modificar sua cópia ou cópias do Programa, ou qualquer parte dele,
gerando assim um trabalho derivado, copiar e distribuir essas modificações ou
trabalhos sob os termos da secção 1 acima, desde que se enquadre nas seguintes
condições:

a) Os arquivos modificados devem conter avisos proeminentes afirmando que você
alterou os arquivos, incluindo a data de qualquer alteração.

b) Deve ser licenciado, sob os termos desta Licença, integralmente e sem custo
algum para terceiros, qualquer trabalho seu que contenha ou seja derivado do
Programa ou de parte dele.

c) Se qualquer programa modificado, quando executado, lê normalmente comandos
interactivamente, tem que fazer com que, quando iniciado o uso interactivo,
seja impresso ou mostrado um anúncio de que não há qualquer garantia (ou então
que você fornece a garantia) e que os utilizadores podem redistribuir o
programa sob estas condições, ainda informando os utilizadores como consultar
uma cópia desta Licença. (Excepção: se o Programa em si é interactivo mas
normalmente não imprime estes tipos de anúncios, então o seu trabalho derivado
não precisa imprimir um anúncio.)

Estas exigências aplicam-se ao trabalho derivado como um todo. Se secções
identificáveis de tal trabalho não são derivadas do Programa, e podem ser
razoavelmente consideradas trabalhos independentes e separados por si só, então
esta Licença, e seus termos, não se aplicam a estas secções caso as distribua
como um trabalho separado. Mas se distribuir as mesmas secções como parte de um
todo que constitui trabalho derivado, a distribuição como um todo tem que
enquadrar-se nos termos desta Licença, cujos direitos para outros licenciados
se estendem ao todo, portanto também para toda e qualquer parte do programa,
independente de quem a escreveu.

Desta forma, esta secção não tem a intenção de reclamar direitos ou contestar
seus direitos sobre o trabalho escrito completamente por si; ao invés disso, a
intenção é a de exercitar o direito de controlar a distribuição de trabalhos,
derivados ou colectivos, baseados no Programa.

Adicionalmente, a mera adição ao Programa (ou a um trabalho derivado deste) de
um outro trabalho num volume de armazenamento ou meio de distribuição não faz
esse outro trabalho seja incluído no âmbito desta Licença.

3. Você pode copiar e distribuir o Programa (ou trabalho derivado, conforme
descrito na Secção 2) em código-objecto ou em forma executável sob os termos
das Secções 1 e 2 acima, desde que cumpra uma das seguintes alienas:

a) O faça acompanhar com o código-fonte completo e em forma acessível por
máquinas, código esse que tem que ser distribuído sob os termos das Secções 1 e
2 acima e em meio normalmente utilizado para o intercâmbio de software; ou,

b) O acompanhe com uma oferta escrita, válida por pelo menos três anos, de
fornecer a qualquer um, com um custo não superior ao custo de distribuição
física do material, uma cópia do código-fonte completo e em forma acessível por
máquinas,  código esse que tem que ser distribuído sob os termos das Secções 1
e 2 acima e em meio normalmente utilizado para o intercâmbio de software; ou,

c) O acompanhe com a informação que você recebeu em relação à oferta de
distribuição do código-fonte correspondente. (Esta alternativa é permitida
somente em distribuição não comerciais, e apenas se você recebeu o programa em
forma de código-objecto ou executável, com uma oferta de acordo com a Subsecção
b) acima.)

O código-fonte de um trabalho corresponde à forma de trabalho preferida para se
fazer modificações. Para um trabalho em forma executável, o código-fonte
completo significa todo o código-fonte de todos os módulos que ele contém, mais
quaisquer arquivos de definição de "interface", mais os "scripts" utilizados
para se controlar a compilação e a instalação do executável. Contudo, como
excepção especial, o código-fonte distribuído não precisa incluir qualquer
componente normalmente distribuído (tanto em forma original quanto binária) com
os maiores componentes (o compilador, o "kernel" etc.) do sistema operativo sob
o qual o executável funciona, a menos que o componente em si acompanhe o
executável.

Se a distribuição do executável ou código-objecto é feita através da oferta de
acesso a cópias em algum lugar, então oferecer o acesso equivalente a cópia, no
mesmo lugar, do código-fonte, equivale à distribuição do código-fonte, mesmo
que terceiros não sejam compelidos a copiar o código-fonte em conjunto com o
código-objecto.

4. Você não pode copiar, modificar, sublicenciar ou distribuir o Programa,
excepto de acordo com as condições expressas nesta Licença. Qualquer outra
tentativa de cópia, modificação, sublicenciamento ou distribuição do Programa
não é valida, e cancelará automaticamente os direitos que lhe foram fornecidos
por esta Licença. No entanto, terceiros que receberam de si cópias ou direitos,
fornecidos sob os termos desta Licença, não terão a sua licença terminada,
desde que permaneçam em total concordância com ela.

5. Você não é obrigado a aceitar esta Licença já que não a assinou. No entanto,
nada mais lhe dará permissão para modificar ou distribuir o Programa ou
trabalhos derivados deste. Estas acções são proibidas por lei, caso você não
aceite esta Licença. Desta forma, ao modificar ou distribuir o Programa (ou
qualquer trabalho derivado do Programa), você estará a indicar a sua total
concordância com os termos desta Licença, nomeadamente os termos e condições
para copiar, distribuir ou modificar o Programa, ou trabalhos baseados nele.

6. Cada vez que redistribuir o Programa (ou qualquer trabalho derivado), os
destinatários adquirirão automaticamente do autor original uma licença para
copiar, distribuir ou modificar o Programa, sujeitos a estes termos e
condições. Você não poderá impor aos destinatários qualquer outra restrição ao
exercício dos direitos então adquiridos. Você não é responsável em garantir a
concordância de terceiros a esta Licença.

7. Se, em consequência de decisões judiciais ou alegações de violação de
patentes ou quaisquer outras razões (não limitadas a assuntos relacionados a
patentes), lhe forem impostas condições (por ordem judicial, acordos ou outras
formas) e que contradigam as condições desta Licença, elas não o livram das
condições desta Licença. Se não puder distribuir de forma a satisfazer
simultaneamente suas obrigações para com esta Licença e para com as outras
obrigações pertinentes, então como consequência você não poderá distribuir o
Programa. Por exemplo, se uma licença de patente não permitir a redistribuição,
sem obrigação ao pagamento de "royalties", por todos aqueles que receberem
cópias directa ou indirectamente de si, então a única forma de você satisfazer
a licença de patente e a esta Licença seria a de desistir completamente de
distribuir o Programa.

Se qualquer parte desta secção for considerada inválida ou não aplicável em
qualquer circunstância particular, o restante da secção aplica-se, e a secção
como um todo aplicar-se-á em outras circunstâncias.

O propósito desta secção não é o de induzi-lo a infringir quaisquer patentes ou
reivindicação de direitos de propriedade de outros, ou a contestar a validade
de quaisquer dessas reivindicações; esta secção tem como único propósito
proteger a integridade dos sistemas de distribuição de software livre, que é
implementado pela prática de licenças públicas. Várias pessoas têm contribuído
generosamente e em grande escala para software distribuído usando este sistema,
na certeza de que sua aplicação é feita de forma consistente; fica a critério
do autor/doador decidir se ele ou ela está disposto(a) a distribuir software
utilizando outro sistema, e um outro detentor de uma licença não pode impor
esta ou qualquer outra escolha.

Esta secção destina-se a tornar bastante claro o que se acredita ser
consequência do restante desta Licença.

8. Se a distribuição e/ou uso do Programa são restringidos em certos países por
patentes ou direitos de autor, o detentor dos direitos de autor original, que
colocou o Programa sob esta Licença, pode incluir uma limitação geográfica de
distribuição, excluindo aqueles países, de forma a apenas permitir a
distribuição nos países não excluídos. Nestes casos, esta Licença incorpora a
limitação como se a mesma constasse escrita nesta Licença.

9. A Free Software Foundation pode publicar versões revistas e/ou novas da
Licença Pública Geral de tempos em tempos. Estas novas versões serão similares
em espírito à versão actual, mas podem diferir em detalhes que resolvam novos
problemas ou situações.

A cada versão é dada um número distinto. Se o Programa especifica um número de
versão específico desta Licença que se aplica a ele e a "qualquer nova versão",
você tem a opção de aceitar os termos e condições daquela versão ou de qualquer
outra versão.
*/
 
// Scale Header types
DEFINE("GANTT_HDAY",1);
DEFINE("GANTT_HWEEK",2);
DEFINE("GANTT_HMONTH",4);
DEFINE("GANTT_HYEAR",8);

// Bar patterns
DEFINE("GANTT_RDIAG",BAND_RDIAG);	// Right diagonal lines
DEFINE("GANTT_LDIAG",BAND_LDIAG); // Left diagonal lines
DEFINE("GANTT_SOLID",BAND_SOLID); // Solid one color
DEFINE("GANTT_VLINE",BAND_VLINE); // Vertical lines
DEFINE("GANTT_HLINE",BAND_HLINE);  // Horizontal lines
DEFINE("GANTT_3DPLANE",BAND_3DPLANE);  // "3D" Plane
DEFINE("GANTT_HVCROSS",BAND_HVCROSS);  // Vertical/Hor crosses
DEFINE("GANTT_DIAGCROSS",BAND_DIAGCROSS); // Diagonal crosses

// Conversion constant
DEFINE("SECPERDAY",3600*24);

// Locales. ONLY KEPT FOR BACKWARDS COMPATIBILITY
// You should use the proper locale strings directly 
// from now on. 
DEFINE("LOCALE_EN","en_UK");
DEFINE("LOCALE_SV","sv_SE");

// Layout of bars
DEFINE("GANTT_EVEN",1);
DEFINE("GANTT_FROMTOP",2);

// Styles for week header
DEFINE("WEEKSTYLE_WNBR",0);
DEFINE("WEEKSTYLE_FIRSTDAY",1);
DEFINE("WEEKSTYLE_FIRSTDAY2",1);

// Styles for month header
DEFINE("MONTHSTYLE_SHORTNAME",0);
DEFINE("MONTHSTYLE_LONGNAME",1);
DEFINE("MONTHSTYLE_LONGNAMEYEAR2",2);
DEFINE("MONTHSTYLE_SHORTNAMEYEAR2",3);
DEFINE("MONTHSTYLE_LONGNAMEYEAR4",4);
DEFINE("MONTHSTYLE_SHORTNAMEYEAR4",5);


//===================================================
// CLASS GanttGraph
// Description: Main class to handle gantt graphs
//===================================================
class GanttGraph extends Graph {
    var $scale;							// Public accessible
    var $iObj=array();				// Gantt objects
    var $iLabelHMarginFactor=0.2;	// 10% margin on each side of the labels
    var $iLabelVMarginFactor=0.4;	// 40% margin on top and bottom of label
    var $iLayout=GANTT_FROMTOP;	// Could also be GANTT_EVEN

//---------------
// CONSTRUCTOR	
    // Create a new gantt graph
    function GanttGraph($aWidth=0,$aHeight=0,$aCachedName="",$aTimeOut=0,$aInline=true) {
	Graph::Graph($aWidth,$aHeight,$aCachedName,$aTimeOut,$aInline);		
	$this->scale = new GanttScale($this->img);
	if( $aWidth > 0 )
		$this->img->SetMargin($aWidth/17,$aWidth/17,$aHeight/7,$aHeight/10);
		
	$this->scale->ShowHeaders(GANTT_HWEEK|GANTT_HDAY);
	$this->SetBox();
    }
	
//---------------
// PUBLIC METHODS	
    // Set what headers should be shown
    function ShowHeaders($aFlg) {
	$this->scale->ShowHeaders($aFlg);
    }
	
    // Specify the fraction of the font height that should be added 
    // as vertical margin
    function SetLabelVMarginFactor($aVal) {
	$this->iLabelVMarginFactor = $aVal;
    }
	
    // Add a new Gantt object
    function Add(&$aObject) {
	if( is_array($aObject) ) {
	    for($i=0; $i<count($aObject); ++$i)
		$this->iObj[] = $aObject[$i];
	}
	else
	    $this->iObj[] = $aObject;
    }

    // Override inherit method from Graph and give a warning message
    function SetScale() {
	JpGraphError::Raise("SetScale() is not meaningfull with Gantt charts.");
	// Empty
    }

    // Specify the date range for Gantt graphs (if this is not set it will be
    // automtically determined from the input data)
    function SetDateRange($aStart,$aEnd) {
	$this->scale->SetRange($aStart,$aEnd);
    }
	
    // Get the maximum width of the titles for the bars	
    function GetMaxLabelWidth() {
	$m=0;
	if( $this->iObj != null ) {
	    $m = $this->iObj[0]->title->GetWidth($this->img);
	    for($i=1; $i<count($this->iObj); ++$i) {
		if( $this->iObj[$i]->title->HasTabs() ) {
		    list($tot,$w) = $this->iObj[$i]->title->GetWidth($this->img,true);
		    $m=max($m,$tot);
		}
		else 
		    $m=max($m,$this->iObj[$i]->title->GetWidth($this->img));
	    }
	}
	return $m;
    }
	
    // Get the maximum height of the titles for the bars
    function GetMaxLabelHeight() {
	$m=0;
	if( $this->iObj != null ) {
	    $m = $this->iObj[0]->title->GetHeight($this->img);
	    for($i=1; $i<count($this->iObj); ++$i) {
		$m=max($m,$this->iObj[$i]->title->GetHeight($this->img));
	    }
	}
	return $m;
    }

    function GetMaxBarAbsHeight() {
	$m=0;
	if( $this->iObj != null ) {
	    $m = $this->iObj[0]->GetAbsHeight($this->img);
	    for($i=1; $i<count($this->iObj); ++$i) {
		$m=max($m,$this->iObj[$i]->GetAbsHeight($this->img));
	    }
	}
	return $m;		
    }
	
    // Get the maximum used line number (vertical position) for bars
    function GetBarMaxLineNumber() {
	$m=0;
	if( $this->iObj != null ) {
	    $m = $this->iObj[0]->GetLineNbr();
	    for($i=1; $i<count($this->iObj); ++$i) {
		$m=max($m,$this->iObj[$i]->GetLineNbr());
	    }
	}
	return $m;
    }
	
    // Get the minumum and maximum used dates for all bars
    function GetBarMinMax() {
	$max=$this->scale->NormalizeDate($this->iObj[0]->GetMaxDate());
	$min=$this->scale->NormalizeDate($this->iObj[0]->GetMinDate());
	for($i=1; $i<count($this->iObj); ++$i) {
	    $max=Max($max,$this->scale->NormalizeDate($this->iObj[$i]->GetMaxDate()));
	    $min=Min($min,$this->scale->NormalizeDate($this->iObj[$i]->GetMinDate()));
	}
	$minDate = date("Y-m-d",$min);
	$min = strtotime($minDate);
	$maxDate = date("Y-m-d",$max);
	$max = strtotime($maxDate);	
	return array($min,$max);
    }

    // Stroke the gantt chart
    function Stroke($aStrokeFileName="") {	


	// Should we autoscale dates?
	if( !$this->scale->IsRangeSet() ) {
	    list($min,$max) = $this->GetBarMinMax();
	    $this->scale->SetRange($min,$max);
	}

	$this->scale->AdjustStartEndDay();
			
	if( $this->img->img == null ) {
	    // The predefined left, right, top, bottom margins.
	    // Note that the top margin might incease depending on
	    // the title.
	    $lm=30;$rm=30;$tm=20;$bm=30;			
	    if( BRAND_TIMING ) $bm += 10;
			
	    // First find out the height			
	    $n=$this->GetBarMaxLineNumber()+1;
	    $m=max($this->GetMaxLabelHeight(),$this->GetMaxBarAbsHeight());
	    $height=$n*((1+$this->iLabelVMarginFactor)*$m);			
			
	    // Add the height of the scale titles			
	    $h=$this->scale->GetHeaderHeight();
	    $height += $h;

	    // Calculate the top margin needed for title and subtitle
	    if( $this->title->t != "" ) {
		$tm += $this->title->GetFontHeight($this->img);
	    }
	    if( $this->subtitle->t != "" ) {
		$tm += $this->subtitle->GetFontHeight($this->img);
	    }

	    // ...and then take the bottom and top plot margins into account
	    $height += $tm + $bm + $this->scale->iTopPlotMargin + $this->scale->iBottomPlotMargin;
			
	    // Now find the minimum width for the chart required
	    $fw=$this->scale->day->GetFontWidth($this->img)+4;
	    $nd=$this->scale->GetNumberOfDays();
	    if( !$this->scale->IsDisplayDay() ) {
				// If we don't display the individual days we can shrink the
				// scale a little bit. This is a little bit pragmatic at the 
				// moment and should be re-written to take into account
				// a) What scales exactly are shown and 
				// b) what format do they use so we know how wide we need to
				// make each scale text space at minimum.
		$fw /= 2;
		if( !$this->scale->IsDisplayWeek() ) {
		    $fw /= 1.8;
		}
	    }

	    // Has the user specified a width or do we need to
	    // determine it?
	    if( $this->img->width <= 0 ) {
		// Now determine the width for the activity titles column
		// This is complicated by the fact that the titles may have
		// tabs. In that case we also need to calculate the individual
		// tab positions based on the width of the individual columns
		
		$titlewidth = $this->GetMaxLabelWidth();
		
		// Now get the total width taking 
		// titlewidth, left and rigt margin, dayfont size 
		// into account
		$width = $titlewidth + $nd*$fw + $lm+$rm;
	    }
	    else
		$width = $this->img->width;
						
	    $this->img->CreateImgCanvas($width,$height);			
	    $this->img->SetMargin($lm,$rm,$tm,$bm);
	}
		
	// Should we start from the top or just spread the bars out even over the
	// available height
	$this->scale->SetVertLayout($this->iLayout);			
	if( $this->iLayout == GANTT_FROMTOP ) {
	    $maxheight=max($this->GetMaxLabelHeight(),$this->GetMaxBarAbsHeight());
	    $this->scale->SetVertSpacing($maxheight*(1+$this->iLabelVMarginFactor));
	}
	// If it hasn't been set find out the maximum line number
	if( $this->scale->iVertLines == -1 ) 
	    $this->scale->iVertLines = $this->GetBarMaxLineNumber()+1; 	
		
	$maxwidth=max($this->GetMaxLabelWidth(),$this->scale->tableTitle->GetWidth($this->img));
	$this->scale->SetLabelWidth($maxwidth*(1+$this->iLabelHMarginFactor));
	$this->StrokePlotArea();
	$this->scale->Stroke();
	$this->StrokePlotBox();
		
	for($i=0; $i<count($this->iObj); ++$i) {
	    $this->iObj[$i]->SetLabelLeftMargin(round($maxwidth*$this->iLabelHMarginFactor/2));
	    $this->iObj[$i]->Stroke($this->img,$this->scale);
	}
		
	$this->StrokeTitles();
	$this->cache->PutAndStream($this->img,$this->cache_name,$this->inline,$aStrokeFileName);				
    }
}

//===================================================
// CLASS TextProperty
// Description: Holds properties for a text
//===================================================
class TextProperty {
    var $iFFamily=FF_FONT1,$iFStyle=FS_NORMAL,$iFSize=10;
    var $iColor="black";
    var $iShow=true;
    var $iText="";
    var $iHAlign="left",$iVAlign="bottom";
	
//---------------
// CONSTRUCTOR	
    function TextProperty($aTxt="") {
	$this->iText = $aTxt;
    }		
	
//---------------
// PUBLIC METHODS	
    function Set($aTxt) {
	$this->iText = $aTxt;
    }
	
    // Set text color
    function SetColor($aColor) {
	$this->iColor = $aColor;
    }
	
    function HasTabs() {
	return substr_count($this->iText,"\t") > 0;
    }
	
    // Get number of tabs in string
    function GetNbrTabs() {
	substr_count($this->iText,"\t");
    }
	
    // Set alignment
    function Align($aHAlign,$aVAlign="bottom") {
	$this->iHAlign=$aHAlign;
	$this->iVAlign=$aVAlign;
    }
	
    // Specify font
    function SetFont($aFFamily,$aFStyle=FS_NORMAL,$aFSize=10) {
	$this->iFFamily = $aFFamily;
	$this->iFStyle	 = $aFStyle;
	$this->iFSize	 = $aFSize;
    }
	
    // Get width of text. If text contains several columns separated by
    // tabs then return both the total width as well as an array with a 
    // width for each column.
    function GetWidth($aImg,$aUseTabs=false,$aTabExtraMargin=1.1) {
	if( strlen($this->iText)== 0 ) return;
	$tmp = split("\t",$this->iText);
	$aImg->SetFont($this->iFFamily,$this->iFStyle,$this->iFSize);
	if( count($tmp) <= 1 || !$aUseTabs ) {
	    return $aImg->GetTextWidth($this->iText);
	}
	else {
	    $tot=0;
	    for($i=0; $i<count($tmp); ++$i) {
		$res[$i] = $aImg->GetTextWidth($tmp[$i]);
		$tot += $res[$i]*$aTabExtraMargin;
	    }
	    return array($tot,$res);
	}
    }
	
    // Get total height of text
    function GetHeight($aImg) {
	$aImg->SetFont($this->iFFamily,$this->iFStyle,$this->iFSize);
	return $aImg->GetFontHeight();
    }
	
    // Unhide/hide the text	
    function Show($aShow) {
	$this->iShow=$aShow;
    }
	
    // Stroke text at (x,y) coordinates. If the text contains tabs then the
    // x parameter should be an array of positions to be used for each successive
    // tab mark. If no array is supplied then the tabs will be ignored.
    function Stroke($aImg,$aX,$aY) {
	if( $this->iShow ) {
	    $aImg->SetColor($this->iColor);
	    $aImg->SetFont($this->iFFamily,$this->iFStyle,$this->iFSize);
	    $aImg->SetTextAlign($this->iHAlign,$this->iVAlign);			
	    if( $this->GetNbrTabs() <= 1 || !is_array($aX) ) {
				// Get rid of any "\t" characters and stroke string
		$aImg->StrokeText($aX,$aY,str_replace("\t"," ",$this->iText));
	    }
	    else {
		$tmp = split("\t",$this->iText);
		$n = min(count($tmp),count($aX));
		for($i=0; $i<$n; ++$i) {
		    $aImg->StrokeText($aX[$i],$aY,$tmp[$i]);
		}	
	    }
	}
    }
}

//===================================================
// CLASS HeaderProperty
// Description: Data encapsulating class to hold property 
// for each type of the scale headers
//===================================================
class HeaderProperty {
    var $iTitleVertMargin=3,$iFFamily=FF_FONT0,$iFStyle=FS_NORMAL,$iFSize=8;
    var $iFrameColor="black",$iFrameWeight=1;
    var $iShowLabels=true,$iShowGrid=true;
    var $iBackgroundColor="white";
    var $iWeekendBackgroundColor="lightgray",$iSundayTextColor="red"; // these are only used with day scale
    var $iTextColor="black";
    var $iLabelFormStr="%d";
    var $grid,$iStyle=0;

//---------------
// CONSTRUCTOR	
    function HeaderProperty() {
	$this->grid = new LineProperty();
    }

//---------------
// PUBLIC METHODS		
    function Show($aShow) {
	$this->iShowLabels = $aShow;
    }
	
    function SetFont($aFFamily,$aFStyle=FS_NORMAL,$aFSize=10) {
	$this->iFFamily = $aFFamily;
	$this->iFStyle	 = $aFStyle;
	$this->iFSize	 = $aFSize;
    }

    function SetFontColor($aColor) {
	$this->iTextColor = $aColor;
    }
	
    function GetFontHeight($aImg) {
	$aImg->SetFont($this->iFFamily,$this->iFStyle,$this->iFSize);
	return $aImg->GetFontHeight();
    }

    function GetFontWidth($aImg) {
	$aImg->SetFont($this->iFFamily,$this->iFStyle,$this->iFSize);
	return $aImg->GetFontWidth();
    }
	
    function SetStyle($aStyle) {
	$this->iStyle = $aStyle;
    }
	
    function SetBackgroundColor($aColor) {
	$this->iBackgroundColor=$aColor;
    }

    function SetFrameWeight($aWeight) {
	$this->iFrameWeight=$aWeight;
    }

    function SetFrameColor($aColor) {
	$this->iFrameColor=$aColor;
    }
	
    // Only used by day scale
    function SetWeekendColor($aColor) {
	$this->iWeekendBackgroundColor=$aColor;
    }
	
    // Only used by day scale
    function SetSundayFontColor($aColor) {
	$this->iSundayTextColor=$aColor;
    }
	
    function SetTitleVertMargin($aMargin) {
	$this->iTitleVertMargin=$aMargin;
    }
	
    function SetLabelFormatString($aStr) {
	$this->iLabelFormStr=$aStr;
    }
}

//===================================================
// CLASS GanttScale
// Description: Responsible for calculating and showing
// the scale in a gantt chart. This includes providing methods for
// converting dates to position in the chart as well as stroking the
// date headers (days, week, etc).
//===================================================
class GanttScale {
    var $day,$week,$month,$year;
    var $divider,$dividerh,$tableTitle;
    var $iStartDate=-1,$iEndDate=-1;
    // Number of gantt bar position (n.b not necessariliy the same as the number of bars)
    // we could have on bar in position 1, and one bar in position 5 then there are two
    // bars but the number of bar positions is 5
    var $iVertLines=-1;	
    // The width of the labels (defaults to the widest of all labels)
    var $iLabelWidth;	
    // Out image to stroke the scale to
    var $iImg;	
    var $iTableHeaderBackgroundColor="white",$iTableHeaderFrameColor="black";
    var $iTableHeaderFrameWeight=1;
    var $iAvailableHeight=-1,$iVertSpacing=-1,$iVertHeaderSize=-1;
    var $iDateLocale;
    var $iVertLayout=GANTT_EVEN;
    var $iTopPlotMargin=10,$iBottomPlotMargin=15;
    var $iUsePlotWeekendBackground=true;
    var $iWeekStart = 1;	// Default to have weekends start on Monday
	
//---------------
// CONSTRUCTOR	
    function GanttScale(&$aImg) {
	$this->iImg = &$aImg;		
	$this->iDateLocale = new DateLocale();
	$this->day = new HeaderProperty();
	$this->day->grid->SetColor("gray");

	$this->week = new HeaderProperty();
	$this->week->SetLabelFormatString("w%d");
	$this->week->SetFont(FF_FONT1);

	$this->month = new HeaderProperty();
	$this->month->SetFont(FF_FONT1,FS_BOLD);

	$this->year = new HeaderProperty();
	$this->year->SetFont(FF_FONT1,FS_BOLD);		
		
	$this->divider=new LineProperty();
	$this->dividerh=new LineProperty();		
	$this->tableTitle=new TextProperty();
    }
	
//---------------
// PUBLIC METHODS	
    // Specify what headers should be visible
    function ShowHeaders($aFlg) {
	$this->day->Show($aFlg & GANTT_HDAY);
	$this->week->Show($aFlg & GANTT_HWEEK);
	$this->month->Show($aFlg & GANTT_HMONTH);
	$this->year->Show($aFlg & GANTT_HYEAR);

	// Make some default settings of gridlines whihc makes sense
	if( $aFlg & GANTT_HWEEK ) {
	    $this->month->grid->Show(false);
	    $this->year->grid->Show(false);
	}
    }
	
    // Should the weekend background stretch all the way down in the plotarea
    function UseWeekendBackground($aShow) {
	$this->iUsePlotWeekendBackground = $aShow;
    }
	
    // Have a range been specified?
    function IsRangeSet() {
	return $this->iStartDate!=-1 && $this->iEndDate!=-1;
    }
	
    // Should the layout be from top or even?
    function SetVertLayout($aLayout) {
	$this->iVertLayout = $aLayout;
    }
	
    // Which locale should be used?
    function SetDateLocale($aLocale) {
	$this->iDateLocale->Set($aLocale);
    }
	
    // Number of days we are showing
    function GetNumberOfDays() {
	return round(($this->iEndDate-$this->iStartDate)/SECPERDAY)+1;
    }
	
    // The width of the actual plot area
    function GetPlotWidth() {
	$img=$this->iImg;
	return $img->width - $img->left_margin - $img->right_margin;
    }

    // Specify the width of the titles(labels) for the activities
    // (This is by default set to the minimum width enought for the
    // widest title)
    function SetLabelWidth($aLabelWidth) {
	$this->iLabelWidth=$aLabelWidth;
	}

	// Which day should the week start?
	// 0==Sun, 1==Monday, 2==Tuesday etc
	function SetWeekStart($aStartDay) {
		$this->iWeekStart = $aStartDay % 7;
		
		//Recalculate the startday since this will change the week start
		$this->SetRange($this->iStartDate,$this->iEndDate);
	}
	
    // Do we show day scale?
    function IsDisplayDay() {
	return $this->day->iShowLabels;
    }
	
    // Do we show week scale?
    function IsDisplayWeek() {
	return $this->week->iShowLabels;
    }
	
    // Do we show month scale?
    function IsDisplayMonth() {
	return $this->month->iShowLabels;
    }
	
    // Do we show year scale?
    function IsDisplayYear() {
	return $this->year->iShowLabels;
    }

    // Specify spacing (in percent of bar height) between activity bars
    function SetVertSpacing($aSpacing) {
	$this->iVertSpacing = $aSpacing;
    }

    // Specify scale min and max date either as timestamp or as date strings
    // Always round to the nearest week boundary
    function SetRange($aMin,$aMax) {
	$this->iStartDate = $this->NormalizeDate($aMin);
	$this->iEndDate = $this->NormalizeDate($aMax);	
	}


	// Adjust the start and end date so they fit to beginning/ending
	// of the week taking the specified week start day into account.
	function AdjustStartEndDay() {
		// Get day in week for start and ending date (Sun==0)
		$ds=strftime("%w",$this->iStartDate);
		$de=strftime("%w",$this->iEndDate);	
	
		// We want to start on iWeekStart day. But first we subtract a week
		// if the startdate is "behind" the day the week start at. 
		// This way we ensure that the given start date is always included 
		// in the range. If we don't do this the nearest correct weekday in the week 
		// to start at might be later than the start date.
		if( $ds < $this->iWeekStart )
			$d = strtotime('-7 day',$this->iStartDate);
		else
			$d = $this->iStartDate;
		$adjdate = strtotime(($this->iWeekStart-$ds).' day',$d /*$this->iStartDate*/ );
		$this->iStartDate = $adjdate;
	
		// We want to end on the last day of the week
		$preferredEndDay = ($this->iWeekStart+6)%7;
		if( $preferredEndDay != $de ) { 
			// Solve equivalence eq:    $de + x ~ $preferredDay (mod 7)
			$adj = (7+($preferredEndDay - $de)) % 7;
			$adjdate = strtotime("+$adj day",$this->iEndDate);
			$this->iEndDate = $adjdate;	
		}	
	}

    // Specify background for the table title area (upper left corner of the table)	
    function SetTableTitleBackground($aColor) {
	$this->iTableHeaderBackgroundColor = $aColor;
    }

///////////////////////////////////////
// PRIVATE Methods
	
    // Determine the height of all the scale headers combined
    function GetHeaderHeight() {
	$img=$this->iImg;
	$height=1;
	if( $this->day->iShowLabels ) {
	    $height += $this->day->GetFontHeight($img);
	    $height += $this->day->iTitleVertMargin;
	}
	if( $this->week->iShowLabels ) {
	    $height += $this->week->GetFontHeight($img);
	    $height += $this->week->iTitleVertMargin;
	}
	if( $this->month->iShowLabels ) {
	    $height += $this->month->GetFontHeight($img);
	    $height += $this->month->iTitleVertMargin;
	}
	if( $this->year->iShowLabels ) {
	    $height += $this->year->GetFontHeight($img);
	    $height += $this->year->iTitleVertMargin;
	}
	return $height;
    }
	
    // Get width (in pisels) for a single day
    function GetDayWidth() {
	return ($this->GetPlotWidth()-$this->iLabelWidth+1)/$this->GetNumberOfDays();	
    }

    // Nuber of days in a year
    function GetNumDaysInYear($aYear) {
	if( $this->IsLeap($aYear) )
	    return 366;
	else
	    return 365;
    }
	
    // Get week number 
    function GetWeekNbr($aDate) {
	// We can't use the internal strftime() since it gets the weeknumber
	// wrong since it doesn't follow ISO.
	// Even worse is that this works differently if we are on a Windows
	// or UNIX box (it even differs between UNIX boxes how strftime()
	// is natively implemented)
	//
	// Credit to Nicolas Hoizey <nhoizey@phpheaven.net> for this elegant
	// version of Week Nbr calculation. 
		
	$day = $this->NormalizeDate($aDate);
		
	/*-------------------------------------------------------------------------
	  According to ISO-8601 :
	  "Week 01 of a year is per definition the first week that has the Thursday in this year,
	  which is equivalent to the week that contains the fourth day of January.
	  In other words, the first week of a new year is the week that has the majority of its
	  days in the new year."
		  
	  Be carefull, with PHP, -3 % 7 = -3, instead of 4 !!!
		  
	  day of year             = date("z", $day) + 1
	  offset to thursday      = 3 - (date("w", $day) + 6) % 7
	  first thursday of year  = 1 + (11 - date("w", mktime(0, 0, 0, 1, 1, date("Y", $day)))) % 7
	  week number             = (thursday's day of year - first thursday's day of year) / 7 + 1
	  ---------------------------------------------------------------------------*/
		 
	$thursday = $day + 60 * 60 * 24 * (3 - (date("w", $day) + 6) % 7);              // take week's thursday
	$week = 1 + (date("z", $thursday) - (11 - date("w", mktime(0, 0, 0, 1, 1, date("Y", $thursday)))) % 7) / 7;
		  
	return $week;
    }
	
    // Is year a leap year?
    function IsLeap($aYear) {
	// Is the year a leap year?
	//$year = 0+date("Y",$aDate);
	if( $aYear % 4 == 0)
	    if( !($aYear % 100 == 0) || ($aYear % 400 == 0) )
		return true;
	return false;
    }

    // Get current year
    function GetYear($aDate) {
	return 0+Date("Y",$aDate);
    }
	
    // Return number of days in a year
    function GetNumDaysInMonth($aMonth,$aYear) {
	$days=array(31,28,31,30,31,30,31,31,30,31,30,31);
	$daysl=array(31,29,31,30,31,30,31,31,30,31,30,31);
	if( $this->IsLeap($aYear))
	    return $daysl[$aMonth];
	else
	    return $days[$aMonth];
    }
	
    // Get day in month
    function GetMonthDayNbr($aDate) {
	return 0+strftime("%d",$aDate);
    }

    // Get day in year
    function GetYearDayNbr($aDate) {
	return 0+strftime("%j",$aDate);
    }
	
    // Get month number
    function GetMonthNbr($aDate) {
	return 0+strftime("%m",$aDate);
    }
	
    // Translate a date to screen coordinates	(horizontal scale)
    function TranslateDate($aDate) {
	$aDate = $this->NormalizeDate($aDate);
	$img=$this->iImg;		
	return ($aDate-$this->iStartDate)/SECPERDAY*$this->GetDayWidth()+$img->left_margin+$this->iLabelWidth;;
    }

    // Get screen coordinatesz for the vertical position for a bar		
    function TranslateVertPos($aPos) {
	$img=$this->iImg;
	$ph=$this->iAvailableHeight;
	if( $aPos > $this->iVertLines ) 
	    JpGraphError::Raise("Illegal vertical position $aPos");
	if( $this->iVertLayout == GANTT_EVEN ) {
	    // Position the top bar at 1 vert spacing from the scale
	    return round($img->top_margin + $this->iVertHeaderSize +  ($aPos+1)*$this->iVertSpacing);
	}
	else {
	    // position the top bar at 1/2 a vert spacing from the scale
	    return round($img->top_margin + $this->iVertHeaderSize  + $this->iTopPlotMargin + ($aPos+1)*$this->iVertSpacing);		
	}
    }
	
    // What is the vertical spacing?
    function GetVertSpacing() {
	return $this->iVertSpacing;
    }
					
    // Convert a date to timestamp
    function NormalizeDate($aDate) {
	if( is_string($aDate) )
	    return strtotime($aDate);
	elseif( is_int($aDate) || is_float($aDate) )
	    return $aDate;
	else
	    JpGraphError::Raise("Unknown date format in GanttScale ($aDate).");
    }

    // Stroke the day scale (including gridlines)			
    function StrokeDays($aYCoord) {
	$wdays=$this->iDateLocale->GetDayAbb();	
	$img=$this->iImg;	
	$daywidth=$this->GetDayWidth();
	$xt=$img->left_margin+$this->iLabelWidth;
	$yt=$aYCoord+$img->top_margin;		
	if( $this->day->iShowLabels ) {
	    $img->SetFont($this->day->iFFamily,$this->day->iFStyle,$this->day->iFSize);
	    $xb=$img->width-$img->right_margin;
	    $yb=$yt + $img->GetFontHeight() + $this->day->iTitleVertMargin + $this->day->iFrameWeight;
	    $img->SetColor($this->day->iBackgroundColor);
	    $img->FilledRectangle($xt,$yt,$xb,$yb);

	    $img->SetColor($this->day->grid->iColor);
	    $x = $xt;   
	    $img->SetTextAlign("center");
	    $day = $this->iWeekStart;
	    //echo "n=".$this->GetNumberOfDays()."<p>";
	    for($i=0; $i<$this->GetNumberOfDays(); ++$i, $x+=$daywidth, $day += 1,$day %= 7) {
		if( $day==6 || $day==0 ) {
		    $img->PushColor($this->day->iWeekendBackgroundColor);
		    if( $this->iUsePlotWeekendBackground )
			$img->FilledRectangle($x,$yt+$this->day->iFrameWeight,$x+$daywidth,$img->height-$img->bottom_margin);						
		    else
			$img->FilledRectangle($x,$yt+$this->day->iFrameWeight,$x+$daywidth,$yb-$this->day->iFrameWeight);
		    $img->PopColor();
		}
		if( $day==0 ) 
		    $img->PushColor($this->day->iSundayTextColor);
		else
		    $img->PushColor($this->day->iTextColor);
		$img->StrokeText(round($x+$daywidth/2+1),
				 round($yb-$this->day->iTitleVertMargin),
				 $wdays[$day]);
		$img->PopColor();						
		$img->Line($x,$yt,$x,$yb);
		$this->day->grid->Stroke($img,$x,$yb,$x,$img->height-$img->bottom_margin);
	    }			
	    $img->SetColor($this->day->iFrameColor);
	    $img->SetLineWeight($this->day->iFrameWeight);
	    $img->Rectangle($xt,$yt,$xb,$yb);
	    return $yb - $img->top_margin;
	}
	return $aYCoord;
    }
	
    // Stroke week header and grid
    function StrokeWeeks($aYCoord) {
	$wdays=$this->iDateLocale->GetDayAbb();	
	$img=$this->iImg;	
	$weekwidth=$this->GetDayWidth()*7;
	$xt=$img->left_margin+$this->iLabelWidth;
	$yt=$aYCoord+$img->top_margin;		
	$img->SetFont($this->week->iFFamily,$this->week->iFStyle,$this->week->iFSize);
	$xb=$img->width-$img->right_margin;
	$yb=$yt + $img->GetFontHeight() + $this->week->iTitleVertMargin + $this->week->iFrameWeight;
		
	$week = $this->iStartDate;
	$weeknbr=$this->GetWeekNbr($week);
	if( $this->week->iShowLabels ) {
	    $img->SetColor($this->week->iBackgroundColor);
	    $img->FilledRectangle($xt,$yt,$xb,$yb);
	    $img->SetColor($this->week->grid->iColor);
	    $x = $xt;
	    if( $this->week->iStyle==WEEKSTYLE_WNBR ) {
		$img->SetTextAlign("center");
		$txtOffset = $weekwidth/2+1;
	    }
	    elseif( $this->week->iStyle==WEEKSTYLE_FIRSTDAY || $this->week->iStyle==WEEKSTYLE_FIRSTDAY2 ) {
		$img->SetTextAlign("left");
		$txtOffset = 2;
	    }
	    else
		JpGraphError::Raise("Unknown formatting style for week.");
				
	    for($i=0; $i<$this->GetNumberOfDays()/7; ++$i, $x+=$weekwidth) {
		$img->PushColor($this->week->iTextColor);
				
		if( $this->week->iStyle==WEEKSTYLE_WNBR )
		    $txt = sprintf($this->week->iLabelFormStr,$weeknbr);
		elseif( $this->week->iStyle==WEEKSTYLE_FIRSTDAY )
		    $txt = date("j/n",$week);
		elseif( $this->week->iStyle==WEEKSTYLE_FIRSTDAY2 ) {
		    $monthnbr = date("n",$week)-1;
		    $shortmonth = $this->iDateLocale->GetShortMonthName($monthnbr);
		    $txt = Date("j",$week)." ".$shortmonth;
		}
				
		$img->StrokeText(round($x+$txtOffset),round($yb-$this->week->iTitleVertMargin),$txt);
				
		$week = strtotime('+7 day',$week); 
		$weeknbr = $this->GetWeekNbr($week);
		$img->PopColor();						
		$img->Line($x,$yt,$x,$yb);
		$this->week->grid->Stroke($img,$x,$yb,$x,$img->height-$img->bottom_margin);
	    }			
	    $img->SetColor($this->week->iFrameColor);
	    $img->SetLineWeight($this->week->iFrameWeight);
	    $img->Rectangle($xt,$yt,$xb,$yb);
	    return $yb-$img->top_margin;
	}
	return $aYCoord;
    }	
	
    // Format the mont scale header string
    function GetMonthLabel($aMonthNbr,$year) {
	$sn = $this->iDateLocale->GetShortMonthName($aMonthNbr);
	$ln = $this->iDateLocale->GetLongMonthName($aMonthNbr);
	switch($this->month->iStyle) {
	    case MONTHSTYLE_SHORTNAME:
		$m=$sn;
	    break;
	    case MONTHSTYLE_LONGNAME:
		$m=$ln;
	    break;
	    case MONTHSTYLE_SHORTNAMEYEAR2:
		$m=$sn." '".substr("".$year,2);
	    break;
	    case MONTHSTYLE_SHORTNAMEYEAR4:
		$m=$sn." ".$year;
	    break;
	    case MONTHSTYLE_LONGNAMEYEAR2:
		$m=$ln." '".substr("".$year,2);
	    break;
	    case MONTHSTYLE_LONGNAMEYEAR4:
		$m=$ln." ".$year;
	    break;
	}
	return $m;
    }
	
    // Stroke month scale and gridlines
    function StrokeMonths($aYCoord) {
	if( $this->month->iShowLabels ) {
	    $monthnbr = $this->GetMonthNbr($this->iStartDate)-1; 
	    $img=$this->iImg;	
		
	    $xt=$img->left_margin+$this->iLabelWidth;
	    $yt=$aYCoord+$img->top_margin;		
	    $img->SetFont($this->month->iFFamily,$this->month->iFStyle,$this->month->iFSize);
	    $xb=$img->width-$img->right_margin;
	    $yb=$yt + $img->GetFontHeight() + $this->month->iTitleVertMargin + $this->month->iFrameWeight;
			
	    $img->SetColor($this->month->iBackgroundColor);
	    $img->FilledRectangle($xt,$yt,$xb,$yb);

	    $img->SetLineWeight($this->month->grid->iWeight);
	    $img->SetColor($this->month->iTextColor);
	    $year = 0+strftime("%Y",$this->iStartDate);
	    $img->SetTextAlign("center");
	    if( $this->GetMonthNbr($this->iStartDate) == $this->GetMonthNbr($this->iEndDate) )
	    	$monthwidth=$this->GetDayWidth()*($this->GetMonthDayNbr($this->iEndDate) - $this->GetMonthDayNbr($this->iStartDate) + 1);
	    else
	    	$monthwidth=$this->GetDayWidth()*($this->GetNumDaysInMonth($monthnbr,$year)-$this->GetMonthDayNbr($this->iStartDate)+1);
	    // Is it enough space to stroke the first month?
	    $monthName = $this->GetMonthLabel($monthnbr,$year);
	    if( $monthwidth >= 1.2*$img->GetTextWidth($monthName) ) {
		$img->SetColor($this->month->iTextColor);				
		$img->StrokeText(round($xt+$monthwidth/2+1),
				 round($yb-$this->month->iTitleVertMargin),
				 $monthName);
	    }
	    $x = $xt + $monthwidth;
	    while( $x < $xb ) {
		$img->SetColor($this->month->grid->iColor);				
		$img->Line($x,$yt,$x,$yb);
		$this->month->grid->Stroke($img,$x,$yb,$x,$img->height-$img->bottom_margin);
		$monthnbr++;
		if( $monthnbr==12 ) {
		    $monthnbr=0;
		    $year++;
		}
		$monthName = $this->GetMonthLabel($monthnbr,$year);
		$monthwidth=$this->GetDayWidth()*$this->GetNumDaysInMonth($monthnbr,$year);				
		if( $x + $monthwidth < $xb )
		    $w = $monthwidth;
		else
		    $w = $xb-$x;
		if( $w >= 1.2*$img->GetTextWidth($monthName) ) {
		    $img->SetColor($this->month->iTextColor);				
		    $img->StrokeText(round($x+$w/2+1),
				     round($yb-$this->month->iTitleVertMargin),$monthName);
		}
		$x += $monthwidth;
	    }	
	    $img->SetColor($this->month->iFrameColor);
	    $img->SetLineWeight($this->month->iFrameWeight);
	    $img->Rectangle($xt,$yt,$xb,$yb);			
	    return $yb-$img->top_margin;
	}
	return $aYCoord;
    }

    // Stroke year scale and gridlines
    function StrokeYears($aYCoord) {
	if( $this->year->iShowLabels ) {
	    $year = $this->GetYear($this->iStartDate); 
	    $img=$this->iImg;	
		
	    $xt=$img->left_margin+$this->iLabelWidth;
	    $yt=$aYCoord+$img->top_margin;		
	    $img->SetFont($this->year->iFFamily,$this->year->iFStyle,$this->year->iFSize);
	    $xb=$img->width-$img->right_margin;
	    $yb=$yt + $img->GetFontHeight() + $this->year->iTitleVertMargin + $this->year->iFrameWeight;
			
	    $img->SetColor($this->year->iBackgroundColor);
	    $img->FilledRectangle($xt,$yt,$xb,$yb);
	    $img->SetLineWeight($this->year->grid->iWeight);
	    $img->SetTextAlign("center");
	    if( $year == $this->GetYear($this->iEndDate) )
		$yearwidth=$this->GetDayWidth()*($this->GetYearDayNbr($this->iEndDate)-$this->GetYearDayNbr($this->iStartDate)+1);
	    else
		$yearwidth=$this->GetDayWidth()*($this->GetNumDaysInYear($year)-$this->GetYearDayNbr($this->iStartDate)+1);
			
	    // The space for a year must be at least 20% bigger than the actual text 
	    // so we allow 10% margin on each side
	    if( $yearwidth >= 1.20*$img->GetTextWidth("".$year) ) {
		$img->SetColor($this->year->iTextColor);				
		$img->StrokeText(round($xt+$yearwidth/2+1),
				 round($yb-$this->year->iTitleVertMargin),
				 $year);
	    }
	    $x = $xt + $yearwidth;
	    while( $x < $xb ) {
		$img->SetColor($this->year->grid->iColor);				
		$img->Line($x,$yt,$x,$yb);
		$this->year->grid->Stroke($img,$x,$yb,$x,$img->height-$img->bottom_margin);
		$year += 1;
		$yearwidth=$this->GetDayWidth()*$this->GetNumDaysInYear($year);				
		if( $x + $yearwidth < $xb )
		    $w = $yearwidth;
		else
		    $w = $xb-$x;
		if( $w >= 1.2*$img->GetTextWidth("".$year) ) {
		    $img->SetColor($this->year->iTextColor);
		    $img->StrokeText(round($x+$w/2+1),
				     round($yb-$this->year->iTitleVertMargin),
				     $year);
		}
		$x += $yearwidth;
	    }
	    $img->SetColor($this->year->iFrameColor);
	    $img->SetLineWeight($this->year->iFrameWeight);
	    $img->Rectangle($xt,$yt,$xb,$yb);			
	    return $yb-$img->top_margin;
	}
	return $aYCoord;
    }
	
    // Stroke table title (upper left corner)
    function StrokeTableHeaders($aYBottom) {
	$img=$this->iImg;
	$xt=$img->left_margin;
	$yt=$img->top_margin;
	$xb=$xt+$this->iLabelWidth;
	$yb=$aYBottom+$img->top_margin;
		
	$img->SetColor($this->iTableHeaderBackgroundColor);
	$img->FilledRectangle($xt,$yt,$xb,$yb);
	$this->tableTitle->Align("center","center");
	$this->tableTitle->Stroke($img,$xt+($xb-$xt)/2+1,$yt+($yb-$yt)/2);		
	$img->SetColor($this->iTableHeaderFrameColor);
	$img->SetLineWeight($this->iTableHeaderFrameWeight);
	$img->Rectangle($xt,$yt,$xb,$yb);
		
	// Draw the vertical dividing line
	$this->divider->Stroke($img,$xb,$yt,$xb,$img->height-$img->bottom_margin);
		
	// Draw the horizontal dividing line		
	$this->dividerh->Stroke($img,$xt,$yb,$img->width-$img->right_margin,$yb);		
    }

    // Main entry point to stroke scale
    function Stroke() {
	if( !$this->IsRangeSet() )
	    JpGraphError::Raise("Gantt scale has not been specified.");
	$img=$this->iImg;
		
	// Stroke all headers. Aa argument we supply the offset from the
	// top which depends on any previous headers
	$offy=$this->StrokeYears(0);
	$offm=$this->StrokeMonths($offy);
	$offw=$this->StrokeWeeks($offm);
	$offd=$this->StrokeDays($offw);

	// We stroke again in case days also have gridlines that may have
	// overwritten the weeks gridline (or month/year). It may seem that we should have logic
	// in the days routine instead but this is much easier and wont make to much
	// of an performance impact.
	$this->StrokeWeeks($offm);		
	$this->StrokeMonths($offy);		
	$this->StrokeYears(0);
	$this->StrokeTableHeaders($offd);
		
	// Now we can calculate the correct scaling factor for each vertical position
	$this->iAvailableHeight = $img->height - $img->top_margin - $img->bottom_margin - $offd;		
	$this->iVertHeaderSize = $offd;
	if( $this->iVertSpacing == -1 )
	    $this->iVertSpacing = $this->iAvailableHeight / $this->iVertLines;
    }	
}

//===================================================
// CLASS GanttPlotObject
// The common signature for a Gantt object
//===================================================
class GanttPlotObject {
    var $iVPos=0;					// Vertical position
    var $iLabelLeftMargin=2;	// Title margin
    var $iStart="";				// Start date
    var $title,$caption;
    var $iCaptionMargin=5;
		
    function GanttPlotObject() {
	$this->title = new TextProperty();
	$this->title->Align("left","center");
	$this->caption = new TextProperty();
    }
	
    function GetMinDate() {
	return $this->iStart;
    }

    function GetMaxDate() {
	return $this->iStart;
    }
	
    function SetCaptionMargin($aMarg) {
	$this->iCaptionMargin=$aMarg;
    }

    function GetAbsHeight($aImg) {
	return 0; 
    }
	
    function GetLineNbr() {
	return $this->iVPos;
    }

    function SetLabelLeftMargin($aOff) {
	$this->iLabelLeftMargin=$aOff;
    }		
}

//===================================================
// CLASS Progress
// Holds parameters for the progress indicator 
// displyed within a bar
//===================================================
class Progress {
    var $iProgress=-1, $iColor="black", $iPattern=GANTT_SOLID;
    var $iDensity=98, $iHeight=0.65; 
	
    function Set($aProg) {
	if( $aProg < 0.0 || $aProg > 1.0 )
	    JpGraphError::Raise("Progress value must in range [0, 1]");
	$this->iProgress = $aProg;
    }

    function SetPattern($aPattern,$aColor="blue",$aDensity=98) {		
	$this->iPattern = $aPattern;
	$this->iColor = $aColor;
	$this->iDensity = $aDensity;
    }
	
    function SetHeight($aHeight) {
	$this->iHeight = $aHeight;
    }
}

//===================================================
// CLASS GanttBar
// Responsible for formatting individual gantt bars
//===================================================
class GanttBar extends GanttPlotObject {
    var $iEnd;
    var $iHeightFactor=0.5;
    var $iFillColor="white",$iFrameColor="blue";
    var $iShadow=false,$iShadowColor="darkgray",$iShadowWidth=1,$iShadowFrame="black";
    var $iPattern=GANTT_RDIAG,$iPatternColor="blue",$iPatternDensity=95;
    var $leftMark,$rightMark;
    var $progress;
	
//---------------
// CONSTRUCTOR	
    function GanttBar($aPos,$aLabel,$aStart,$aEnd,$aCaption="",$aHeightFactor=0.6) {
	parent::GanttPlotObject();	
	$this->iStart = $aStart;	
	// Is the end date given as a date or as number of days added to start date?
	if( is_string($aEnd) )
	    $this->iEnd = strtotime($aEnd)+SECPERDAY;
	elseif(is_int($aEnd) || is_float($aEnd) ) 
	    $this->iEnd = strtotime($aStart)+round($aEnd*SECPERDAY);
	$this->iVPos = $aPos;
	$this->iHeightFactor = $aHeightFactor;
	$this->title->Set($aLabel);
	$this->caption = new TextProperty($aCaption);
	$this->caption->Align("left","center");
	$this->leftMark =new PlotMark();
	$this->leftMark->Hide();
	$this->rightMark=new PlotMark();
	$this->rightMark->Hide();
	$this->progress = new Progress();
    }
	
//---------------
// PUBLIC METHODS	
    function SetShadow($aShadow=true,$aColor="gray") {
	$this->iShadow=$aShadow;
	$this->iShadowColor=$aColor;
    }
		
    function GetMaxDate() {
	return $this->iEnd;
    }
	
    function SetHeight($aHeight) {
	$this->iHeightFactor = $aHeight;
    }

    function SetColor($aColor) {
	$this->iFrameColor = $aColor;
    }

    function SetFillColor($aColor) {
	$this->iFillColor = $aColor;
    }

    function GetAbsHeight($aImg) {
	if( is_int($this->iHeightFactor) || $this->leftMark->show || $this->rightMark->show ) {
	    $m=-1;
	    if( is_int($this->iHeightFactor) )
		$m = $this->iHeightFactor;
	    if( $this->leftMark->show ) 
		$m = max($m,$this->leftMark->width*2);
	    if( $this->rightMark->show ) 
		$m = max($m,$this->rightMark->width*2);
	    return $m;
	}
	else
	    return -1;
    }
	
    function SetPattern($aPattern,$aColor="blue",$aDensity=95) {		
	$this->iPattern = $aPattern;
	$this->iPatternColor = $aColor;
	$this->iPatternDensity = $aDensity;
    }

    function Stroke($aImg,$aScale) {
	$factory = new RectPatternFactory();
	$prect = $factory->Create($this->iPattern,$this->iPatternColor);
	$prect->SetDensity($this->iPatternDensity);

	// If height factor is specified as a float between 0,1 then we take it as meaning
	// percetage of the scale width between horizontal line.
	// If it is an integer > 1 we take it to mean the absolute height in pixels
	if( $this->iHeightFactor > -0.0 && $this->iHeightFactor <= 1.1)
	    $vs = $aScale->GetVertSpacing()*$this->iHeightFactor;
	elseif(is_int($this->iHeightFactor) && $this->iHeightFactor>2 && $this->iHeightFactor<200)
	    $vs = $this->iHeightFactor;
	else
	    JpGraphError::Raise("Specified height (".$this->iHeightFactor.") for gantt bar is out of range.");
	
	// Clip date to min max dates to show
	$st = $aScale->NormalizeDate($this->iStart);
	$en = $aScale->NormalizeDate($this->iEnd);
	

	$limst = max($st,$aScale->iStartDate);
	$limen = min($en,$aScale->iEndDate+SECPERDAY);
			
	$xt = $aScale->TranslateDate($limst);
	$xb = $aScale->TranslateDate($limen)-1;
	$yt = $aScale->TranslateVertPos($this->iVPos)-$vs-($aScale->GetVertSpacing()/2-$vs/2);
	$yb = $aScale->TranslateVertPos($this->iVPos)-($aScale->GetVertSpacing()/2-$vs/2);
	$middle = round($yt+($yb-$yt)/2);
	$this->title->Stroke($aImg,$aImg->left_margin+$this->iLabelLeftMargin,$middle);		

	// Check if the bar is outside the current range
	if( $en <  $aScale->iStartDate+SECPERDAY || $st > $aScale->iEndDate )
		return;
					
	$prect->ShowFrame(false);
	$prect->SetBackground($this->iFillColor);
	if( $this->iShadow ) {
	    $aImg->SetColor($this->iFrameColor);
	    $aImg->ShadowRectangle($xt,$yt,$xb,$yb,$this->iFillColor,$this->iShadowWidth,$this->iShadowColor);				
	    $prect->SetPos(new Rectangle($xt+1,$yt+1,$xb-$xt-$this->iShadowWidth-2,$yb-$yt-$this->iShadowWidth-2));				
	    $prect->Stroke($aImg);
	}
	else {	
	    $prect->SetPos(new Rectangle($xt,$yt,$xb-$xt+1,$yb-$yt+1));				
	    $prect->Stroke($aImg);
	    $aImg->SetColor($this->iFrameColor);
	    $aImg->Rectangle($xt,$yt,$xb,$yb);
	}
	if( $this->progress->iProgress > 0 ) {
		
		//echo "test <p>";
		$xtp = $aScale->TranslateDate($st);
		$xbp = $aScale->TranslateDate($en);
		$len = ($xbp-$xtp)*$this->progress->iProgress;
		$endpos = $xtp+$len;
		if( $endpos > $xt ) {
			
			$len -= ($xt-$xtp); 
			
			//echo "diff in days : ".(($xt-$xtp)/$aScale->GetDayWidth())."<p>";
			
			//echo "xtp=$xtp, len=$len, xt=$xt<p>";
			
			if( $xtp < $xt ) $xtp = $xt;
		
		    $prog = $factory->Create($this->progress->iPattern,$this->progress->iColor);
		    $prog->SetDensity($this->progress->iDensity);
	    	$barheight = ($yb-$yt+1);
		    if( $this->iShadow ) 
				$barheight -= $this->iShadowWidth;
		    $progressheight = floor($barheight*$this->progress->iHeight);
		    $marg = ceil(($barheight-$progressheight)/2);
	    	$pos = new Rectangle($xtp,$yt + $marg, $len,$barheight-2*$marg);
		    $prog->SetPos($pos);
		    $prog->Stroke($aImg);
		}
	}


	// We don't plot the end mark if the bar has been capped
	if( $limst == $st )
		$this->leftMark->Stroke($aImg,$xt,$middle);
	if( $limen == $en )	{
		$this->rightMark->Stroke($aImg,$xb,$middle);
		$margin = $this->iCaptionMargin;
		if( $this->rightMark->show ) 
	    	$margin += $this->rightMark->GetWidth();
		$this->caption->Stroke($aImg,$xb+$margin,$middle);		
	}
	
    }
}

//===================================================
// CLASS MileStone
// Responsible for formatting individual milestones
//===================================================
class MileStone extends GanttPlotObject {
    var $mark;
	
//---------------
// CONSTRUCTOR	
    function MileStone($aVPos,$aLabel,$aDate,$aCaption="") {
	GanttPlotObject::GanttPlotObject();
	$this->caption->Set($aCaption);
	$this->caption->Align("left","center");
	$this->caption->SetFont(FF_FONT1,FS_BOLD);
	$this->title->Set($aLabel);
	$this->title->SetColor("darkred");
	$this->mark = new PlotMark();
	$this->mark->SetWidth(10);
	$this->mark->SetType(MARK_DIAMOND);
	$this->mark->SetColor("darkred");
	$this->mark->SetFillColor("darkred");
	$this->iVPos = $aVPos;
	$this->iStart = $aDate;
    }
	
//---------------
// PUBLIC METHODS	
	
    function GetAbsHeight($aImg) {
	return max($this->title->GetHeight($aImg),$this->mark->GetWidth());
    }
		
    function Stroke($aImg,$aScale) {
	// Put the mark in the middle at the middle of the day
	$d = $aScale->NormalizeDate($this->iStart)+SECPERDAY/2;
	$x = $aScale->TranslateDate($d);
	$y = $aScale->TranslateVertPos($this->iVPos)-($aScale->GetVertSpacing()/2);
	$this->title->Stroke($aImg,$aImg->left_margin+$this->iLabelLeftMargin,$y);

	if( $d <  $aScale->iStartDate || $d > $aScale->iEndDate )
		return;
			
	$this->mark->Stroke($aImg,$x,$y);		
	$this->caption->Stroke($aImg,$x+$this->mark->width/2+$this->iCaptionMargin,$y);
    }
}


//===================================================
// CLASS GanttVLine
// Responsible for formatting individual milestones
//===================================================

class GanttVLine extends GanttPlotObject {

    var $iLine,$title_margin=3;
    var $iDayOffset=1;	// Defult to right edge of day
	
//---------------
// CONSTRUCTOR	
    function GanttVLine($aDate,$aTitle="",$aColor="black",$aWeight=3,$aStyle="dashed") {
	GanttPlotObject::GanttPlotObject();
	$this->iLine = new LineProperty();
	$this->iLine->SetColor($aColor);
	$this->iLine->SetWeight($aWeight);
	$this->iLine->SetStyle($aStyle);
	$this->iStart = $aDate;
	$this->title->Set($aTitle);
    }

//---------------
// PUBLIC METHODS	

    function SetDayOffset($aOff=0.5) {
	if( $aOff < 0.0 || $aOff > 1.0 )
	    JpGraphError::Raise("Offset for vertical line must be in range [0,1]");
	$this->iDayOffset = $aOff;
    }
	
    function SetTitleMargin($aMarg) {
	$this->title_margin = $aMarg;
    }
	
    function Stroke($aImg,$aScale) {
    $d = $aScale->NormalizeDate($this->iStart)+$this->iDayOffset*SECPERDAY;

	if( $d <  $aScale->iStartDate || $d > $aScale->iEndDate )
		return;	

	$x = $aScale->TranslateDate($d);	
	$y1 = $aScale->iVertHeaderSize+$aImg->top_margin;
	$y2 = $aImg->height - $aImg->bottom_margin;	
	$this->iLine->Stroke($aImg,$x,$y1,$x,$y2);
	$this->title->Align("center","top");
	$this->title->Stroke($aImg,$x,$y2+$this->title_margin);
    }	
}

// <EOF>
?>
